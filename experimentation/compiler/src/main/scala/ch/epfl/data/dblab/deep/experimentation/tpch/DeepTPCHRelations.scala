/* Generated by Purgatory 2014-2017 */

package ch.epfl.data.dblab.deep.experimentation.tpch

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

import ch.epfl.data.sc.pardis.quasi.anf.{ BaseExt, BaseExtIR }
import ch.epfl.data.sc.pardis.quasi.TypeParameters.MaybeParamTag

trait LINEITEMRecordOps extends Base with OptimalStringOps {
  // Type representation
  val LINEITEMRecordType = LINEITEMRecordIRs.LINEITEMRecordType
  implicit val typeLINEITEMRecord: TypeRep[LINEITEMRecord] = LINEITEMRecordType
  implicit class LINEITEMRecordRep(self: Rep[LINEITEMRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = lINEITEMRecordGetField(self, key)
    def L_COMMENT: Rep[OptimalString] = lINEITEMRecord_Field_L_COMMENT(self)
    def L_SHIPMODE: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPMODE(self)
    def L_SHIPINSTRUCT: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
    def L_RECEIPTDATE: Rep[Int] = lINEITEMRecord_Field_L_RECEIPTDATE(self)
    def L_COMMITDATE: Rep[Int] = lINEITEMRecord_Field_L_COMMITDATE(self)
    def L_SHIPDATE: Rep[Int] = lINEITEMRecord_Field_L_SHIPDATE(self)
    def L_LINESTATUS: Rep[Char] = lINEITEMRecord_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Char] = lINEITEMRecord_Field_L_RETURNFLAG(self)
    def L_TAX: Rep[Double] = lINEITEMRecord_Field_L_TAX(self)
    def L_DISCOUNT: Rep[Double] = lINEITEMRecord_Field_L_DISCOUNT(self)
    def L_EXTENDEDPRICE: Rep[Double] = lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
    def L_QUANTITY: Rep[Double] = lINEITEMRecord_Field_L_QUANTITY(self)
    def L_LINENUMBER: Rep[Int] = lINEITEMRecord_Field_L_LINENUMBER(self)
    def L_SUPPKEY: Rep[Int] = lINEITEMRecord_Field_L_SUPPKEY(self)
    def L_PARTKEY: Rep[Int] = lINEITEMRecord_Field_L_PARTKEY(self)
    def L_ORDERKEY: Rep[Int] = lINEITEMRecord_Field_L_ORDERKEY(self)
  }
  object LINEITEMRecord {
    def apply(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordApplyObject(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  }
  // constructors
  def __newLINEITEMRecord(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  // IR defs
  val LINEITEMRecordNew = LINEITEMRecordIRs.LINEITEMRecordNew
  type LINEITEMRecordNew = LINEITEMRecordIRs.LINEITEMRecordNew
  val LINEITEMRecordGetField = LINEITEMRecordIRs.LINEITEMRecordGetField
  type LINEITEMRecordGetField = LINEITEMRecordIRs.LINEITEMRecordGetField
  val LINEITEMRecord_Field_L_COMMENT = LINEITEMRecordIRs.LINEITEMRecord_Field_L_COMMENT
  type LINEITEMRecord_Field_L_COMMENT = LINEITEMRecordIRs.LINEITEMRecord_Field_L_COMMENT
  val LINEITEMRecord_Field_L_SHIPMODE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SHIPMODE
  type LINEITEMRecord_Field_L_SHIPMODE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SHIPMODE
  val LINEITEMRecord_Field_L_SHIPINSTRUCT = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SHIPINSTRUCT
  type LINEITEMRecord_Field_L_SHIPINSTRUCT = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SHIPINSTRUCT
  val LINEITEMRecord_Field_L_RECEIPTDATE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_RECEIPTDATE
  type LINEITEMRecord_Field_L_RECEIPTDATE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_RECEIPTDATE
  val LINEITEMRecord_Field_L_COMMITDATE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_COMMITDATE
  type LINEITEMRecord_Field_L_COMMITDATE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_COMMITDATE
  val LINEITEMRecord_Field_L_SHIPDATE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SHIPDATE
  type LINEITEMRecord_Field_L_SHIPDATE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SHIPDATE
  val LINEITEMRecord_Field_L_LINESTATUS = LINEITEMRecordIRs.LINEITEMRecord_Field_L_LINESTATUS
  type LINEITEMRecord_Field_L_LINESTATUS = LINEITEMRecordIRs.LINEITEMRecord_Field_L_LINESTATUS
  val LINEITEMRecord_Field_L_RETURNFLAG = LINEITEMRecordIRs.LINEITEMRecord_Field_L_RETURNFLAG
  type LINEITEMRecord_Field_L_RETURNFLAG = LINEITEMRecordIRs.LINEITEMRecord_Field_L_RETURNFLAG
  val LINEITEMRecord_Field_L_TAX = LINEITEMRecordIRs.LINEITEMRecord_Field_L_TAX
  type LINEITEMRecord_Field_L_TAX = LINEITEMRecordIRs.LINEITEMRecord_Field_L_TAX
  val LINEITEMRecord_Field_L_DISCOUNT = LINEITEMRecordIRs.LINEITEMRecord_Field_L_DISCOUNT
  type LINEITEMRecord_Field_L_DISCOUNT = LINEITEMRecordIRs.LINEITEMRecord_Field_L_DISCOUNT
  val LINEITEMRecord_Field_L_EXTENDEDPRICE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_EXTENDEDPRICE
  type LINEITEMRecord_Field_L_EXTENDEDPRICE = LINEITEMRecordIRs.LINEITEMRecord_Field_L_EXTENDEDPRICE
  val LINEITEMRecord_Field_L_QUANTITY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_QUANTITY
  type LINEITEMRecord_Field_L_QUANTITY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_QUANTITY
  val LINEITEMRecord_Field_L_LINENUMBER = LINEITEMRecordIRs.LINEITEMRecord_Field_L_LINENUMBER
  type LINEITEMRecord_Field_L_LINENUMBER = LINEITEMRecordIRs.LINEITEMRecord_Field_L_LINENUMBER
  val LINEITEMRecord_Field_L_SUPPKEY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SUPPKEY
  type LINEITEMRecord_Field_L_SUPPKEY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_SUPPKEY
  val LINEITEMRecord_Field_L_PARTKEY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_PARTKEY
  type LINEITEMRecord_Field_L_PARTKEY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_PARTKEY
  val LINEITEMRecord_Field_L_ORDERKEY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_ORDERKEY
  type LINEITEMRecord_Field_L_ORDERKEY = LINEITEMRecordIRs.LINEITEMRecord_Field_L_ORDERKEY
  // method definitions
  def lINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = LINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  def lINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]): Rep[Option[Any]] = LINEITEMRecordGetField(self, key)
  def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_COMMENT(self)
  def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPMODE(self)
  def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPINSTRUCT(self)
  def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_RECEIPTDATE(self)
  def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_COMMITDATE(self)
  def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SHIPDATE(self)
  def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Char] = LINEITEMRecord_Field_L_LINESTATUS(self)
  def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Char] = LINEITEMRecord_Field_L_RETURNFLAG(self)
  def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_TAX(self)
  def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_DISCOUNT(self)
  def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_EXTENDEDPRICE(self)
  def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_QUANTITY(self)
  def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_LINENUMBER(self)
  def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SUPPKEY(self)
  def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_PARTKEY(self)
  def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_ORDERKEY(self)
  def lINEITEMRecordApplyObject(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = {
    __newLINEITEMRecord(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  }
  type LINEITEMRecord = ch.epfl.data.dblab.experimentation.tpch.LINEITEMRecord
}
object LINEITEMRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object LINEITEMRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[LINEITEMRecord](scala.reflect.runtime.universe.typeOf[LINEITEMRecord]) {
    override def isRecord = true
  }
  implicit val typeLINEITEMRecord: TypeRep[LINEITEMRecord] = LINEITEMRecordType
  // case classes
  case class LINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]) extends ConstructorDef[LINEITEMRecord](List(), "LINEITEMRecord", List(List(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class LINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class LINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPMODE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_SHIPMODE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]) extends FieldDef[OptimalString](self, "L_SHIPINSTRUCT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_SHIPINSTRUCT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_RECEIPTDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_RECEIPTDATE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_COMMITDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_COMMITDATE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_SHIPDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_SHIPDATE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]) extends FieldDef[Char](self, "L_LINESTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Char = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_LINESTATUS
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]) extends FieldDef[Char](self, "L_RETURNFLAG") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Char = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_RETURNFLAG
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_TAX") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_TAX
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_DISCOUNT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_DISCOUNT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_EXTENDEDPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_EXTENDEDPRICE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]) extends FieldDef[Double](self, "L_QUANTITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_QUANTITY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_LINENUMBER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_LINENUMBER
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_SUPPKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_PARTKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]) extends FieldDef[Int](self, "L_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[LINEITEMRecord]
      self.L_ORDERKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type LINEITEMRecord = ch.epfl.data.dblab.experimentation.tpch.LINEITEMRecord
}
trait LINEITEMRecordImplicits extends LINEITEMRecordOps {
  // Add implicit conversions here!
}
trait LINEITEMRecordComponent extends LINEITEMRecordOps with LINEITEMRecordImplicits {}

trait LINEITEMRecordPartialEvaluation extends LINEITEMRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_COMMENT
    case _                            => super.lINEITEMRecord_Field_L_COMMENT(self)
  }
  override def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SHIPMODE
    case _                            => super.lINEITEMRecord_Field_L_SHIPMODE(self)
  }
  override def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SHIPINSTRUCT
    case _                            => super.lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
  }
  override def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_RECEIPTDATE
    case _                            => super.lINEITEMRecord_Field_L_RECEIPTDATE(self)
  }
  override def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_COMMITDATE
    case _                            => super.lINEITEMRecord_Field_L_COMMITDATE(self)
  }
  override def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SHIPDATE
    case _                            => super.lINEITEMRecord_Field_L_SHIPDATE(self)
  }
  override def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Char] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_LINESTATUS
    case _                            => super.lINEITEMRecord_Field_L_LINESTATUS(self)
  }
  override def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Char] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_RETURNFLAG
    case _                            => super.lINEITEMRecord_Field_L_RETURNFLAG(self)
  }
  override def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_TAX
    case _                            => super.lINEITEMRecord_Field_L_TAX(self)
  }
  override def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_DISCOUNT
    case _                            => super.lINEITEMRecord_Field_L_DISCOUNT(self)
  }
  override def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_EXTENDEDPRICE
    case _                            => super.lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
  }
  override def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_QUANTITY
    case _                            => super.lINEITEMRecord_Field_L_QUANTITY(self)
  }
  override def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_LINENUMBER
    case _                            => super.lINEITEMRecord_Field_L_LINENUMBER(self)
  }
  override def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_SUPPKEY
    case _                            => super.lINEITEMRecord_Field_L_SUPPKEY(self)
  }
  override def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_PARTKEY
    case _                            => super.lINEITEMRecord_Field_L_PARTKEY(self)
  }
  override def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = self match {
    case Def(node: LINEITEMRecordNew) => node.L_ORDERKEY
    case _                            => super.lINEITEMRecord_Field_L_ORDERKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object LINEITEMRecordQuasiNodes extends BaseExtIR {
  import LINEITEMRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class LINEITEMRecordNewExt(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]) extends FunctionDef[LINEITEMRecordNew, LINEITEMRecord] {
    override def nodeUnapply(t: LINEITEMRecordNew): Option[Product] = (LINEITEMRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecordGetFieldExt(self: Rep[LINEITEMRecord], key: Rep[String]) extends FunctionDef[LINEITEMRecordGetField, Option[Any]] {
    override def nodeUnapply(t: LINEITEMRecordGetField): Option[Product] = (LINEITEMRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_COMMENTExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_COMMENT, OptimalString] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_COMMENT): Option[Product] = (LINEITEMRecord_Field_L_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_SHIPMODEExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_SHIPMODE, OptimalString] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_SHIPMODE): Option[Product] = (LINEITEMRecord_Field_L_SHIPMODE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_SHIPINSTRUCTExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_SHIPINSTRUCT, OptimalString] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_SHIPINSTRUCT): Option[Product] = (LINEITEMRecord_Field_L_SHIPINSTRUCT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_RECEIPTDATEExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_RECEIPTDATE, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_RECEIPTDATE): Option[Product] = (LINEITEMRecord_Field_L_RECEIPTDATE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_COMMITDATEExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_COMMITDATE, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_COMMITDATE): Option[Product] = (LINEITEMRecord_Field_L_COMMITDATE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_SHIPDATEExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_SHIPDATE, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_SHIPDATE): Option[Product] = (LINEITEMRecord_Field_L_SHIPDATE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_LINESTATUSExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_LINESTATUS, Char] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_LINESTATUS): Option[Product] = (LINEITEMRecord_Field_L_LINESTATUS.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_RETURNFLAGExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_RETURNFLAG, Char] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_RETURNFLAG): Option[Product] = (LINEITEMRecord_Field_L_RETURNFLAG.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_TAXExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_TAX, Double] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_TAX): Option[Product] = (LINEITEMRecord_Field_L_TAX.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_DISCOUNTExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_DISCOUNT, Double] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_DISCOUNT): Option[Product] = (LINEITEMRecord_Field_L_DISCOUNT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_EXTENDEDPRICEExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_EXTENDEDPRICE, Double] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_EXTENDEDPRICE): Option[Product] = (LINEITEMRecord_Field_L_EXTENDEDPRICE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_QUANTITYExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_QUANTITY, Double] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_QUANTITY): Option[Product] = (LINEITEMRecord_Field_L_QUANTITY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_LINENUMBERExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_LINENUMBER, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_LINENUMBER): Option[Product] = (LINEITEMRecord_Field_L_LINENUMBER.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_SUPPKEYExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_SUPPKEY, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_SUPPKEY): Option[Product] = (LINEITEMRecord_Field_L_SUPPKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_PARTKEYExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_PARTKEY, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_PARTKEY): Option[Product] = (LINEITEMRecord_Field_L_PARTKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class LINEITEMRecord_Field_L_ORDERKEYExt(self: Rep[LINEITEMRecord]) extends FunctionDef[LINEITEMRecord_Field_L_ORDERKEY, Int] {
    override def nodeUnapply(t: LINEITEMRecord_Field_L_ORDERKEY): Option[Product] = (LINEITEMRecord_Field_L_ORDERKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type LINEITEMRecord = ch.epfl.data.dblab.experimentation.tpch.LINEITEMRecord
}

trait LINEITEMRecordExtOps extends BaseExt with OptimalStringExtOps {

  import LINEITEMRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class LINEITEMRecordRep(self: Rep[LINEITEMRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = lINEITEMRecordGetField(self, key)
    def L_COMMENT: Rep[OptimalString] = lINEITEMRecord_Field_L_COMMENT(self)
    def L_SHIPMODE: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPMODE(self)
    def L_SHIPINSTRUCT: Rep[OptimalString] = lINEITEMRecord_Field_L_SHIPINSTRUCT(self)
    def L_RECEIPTDATE: Rep[Int] = lINEITEMRecord_Field_L_RECEIPTDATE(self)
    def L_COMMITDATE: Rep[Int] = lINEITEMRecord_Field_L_COMMITDATE(self)
    def L_SHIPDATE: Rep[Int] = lINEITEMRecord_Field_L_SHIPDATE(self)
    def L_LINESTATUS: Rep[Char] = lINEITEMRecord_Field_L_LINESTATUS(self)
    def L_RETURNFLAG: Rep[Char] = lINEITEMRecord_Field_L_RETURNFLAG(self)
    def L_TAX: Rep[Double] = lINEITEMRecord_Field_L_TAX(self)
    def L_DISCOUNT: Rep[Double] = lINEITEMRecord_Field_L_DISCOUNT(self)
    def L_EXTENDEDPRICE: Rep[Double] = lINEITEMRecord_Field_L_EXTENDEDPRICE(self)
    def L_QUANTITY: Rep[Double] = lINEITEMRecord_Field_L_QUANTITY(self)
    def L_LINENUMBER: Rep[Int] = lINEITEMRecord_Field_L_LINENUMBER(self)
    def L_SUPPKEY: Rep[Int] = lINEITEMRecord_Field_L_SUPPKEY(self)
    def L_PARTKEY: Rep[Int] = lINEITEMRecord_Field_L_PARTKEY(self)
    def L_ORDERKEY: Rep[Int] = lINEITEMRecord_Field_L_ORDERKEY(self)
  }
  object LINEITEMRecord {
    def apply(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordApplyObject(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  }
  // constructors
  def __newLINEITEMRecord(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = lINEITEMRecordNew(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)

  // method definitions
  def lINEITEMRecordApplyObject(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = { __newLINEITEMRecord(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT) }
  def lINEITEMRecordNew(L_ORDERKEY: Rep[Int], L_PARTKEY: Rep[Int], L_SUPPKEY: Rep[Int], L_LINENUMBER: Rep[Int], L_QUANTITY: Rep[Double], L_EXTENDEDPRICE: Rep[Double], L_DISCOUNT: Rep[Double], L_TAX: Rep[Double], L_RETURNFLAG: Rep[Char], L_LINESTATUS: Rep[Char], L_SHIPDATE: Rep[Int], L_COMMITDATE: Rep[Int], L_RECEIPTDATE: Rep[Int], L_SHIPINSTRUCT: Rep[OptimalString], L_SHIPMODE: Rep[OptimalString], L_COMMENT: Rep[OptimalString]): Rep[LINEITEMRecord] = LINEITEMRecordNewExt(L_ORDERKEY, L_PARTKEY, L_SUPPKEY, L_LINENUMBER, L_QUANTITY, L_EXTENDEDPRICE, L_DISCOUNT, L_TAX, L_RETURNFLAG, L_LINESTATUS, L_SHIPDATE, L_COMMITDATE, L_RECEIPTDATE, L_SHIPINSTRUCT, L_SHIPMODE, L_COMMENT)
  def lINEITEMRecordGetField(self: Rep[LINEITEMRecord], key: Rep[String]): Rep[Option[Any]] = LINEITEMRecordGetFieldExt(self, key)
  def lINEITEMRecord_Field_L_COMMENT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_COMMENTExt(self)
  def lINEITEMRecord_Field_L_SHIPMODE(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPMODEExt(self)
  def lINEITEMRecord_Field_L_SHIPINSTRUCT(self: Rep[LINEITEMRecord]): Rep[OptimalString] = LINEITEMRecord_Field_L_SHIPINSTRUCTExt(self)
  def lINEITEMRecord_Field_L_RECEIPTDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_RECEIPTDATEExt(self)
  def lINEITEMRecord_Field_L_COMMITDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_COMMITDATEExt(self)
  def lINEITEMRecord_Field_L_SHIPDATE(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SHIPDATEExt(self)
  def lINEITEMRecord_Field_L_LINESTATUS(self: Rep[LINEITEMRecord]): Rep[Char] = LINEITEMRecord_Field_L_LINESTATUSExt(self)
  def lINEITEMRecord_Field_L_RETURNFLAG(self: Rep[LINEITEMRecord]): Rep[Char] = LINEITEMRecord_Field_L_RETURNFLAGExt(self)
  def lINEITEMRecord_Field_L_TAX(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_TAXExt(self)
  def lINEITEMRecord_Field_L_DISCOUNT(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_DISCOUNTExt(self)
  def lINEITEMRecord_Field_L_EXTENDEDPRICE(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_EXTENDEDPRICEExt(self)
  def lINEITEMRecord_Field_L_QUANTITY(self: Rep[LINEITEMRecord]): Rep[Double] = LINEITEMRecord_Field_L_QUANTITYExt(self)
  def lINEITEMRecord_Field_L_LINENUMBER(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_LINENUMBERExt(self)
  def lINEITEMRecord_Field_L_SUPPKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_SUPPKEYExt(self)
  def lINEITEMRecord_Field_L_PARTKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_PARTKEYExt(self)
  def lINEITEMRecord_Field_L_ORDERKEY(self: Rep[LINEITEMRecord]): Rep[Int] = LINEITEMRecord_Field_L_ORDERKEYExt(self)
  type LINEITEMRecord = ch.epfl.data.dblab.experimentation.tpch.LINEITEMRecord
}

trait ORDERSRecordOps extends Base with OptimalStringOps {
  // Type representation
  val ORDERSRecordType = ORDERSRecordIRs.ORDERSRecordType
  implicit val typeORDERSRecord: TypeRep[ORDERSRecord] = ORDERSRecordType
  implicit class ORDERSRecordRep(self: Rep[ORDERSRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = oRDERSRecordGetField(self, key)
    def O_COMMENT: Rep[OptimalString] = oRDERSRecord_Field_O_COMMENT(self)
    def O_SHIPPRIORITY: Rep[Int] = oRDERSRecord_Field_O_SHIPPRIORITY(self)
    def O_CLERK: Rep[OptimalString] = oRDERSRecord_Field_O_CLERK(self)
    def O_ORDERPRIORITY: Rep[OptimalString] = oRDERSRecord_Field_O_ORDERPRIORITY(self)
    def O_ORDERDATE: Rep[Int] = oRDERSRecord_Field_O_ORDERDATE(self)
    def O_TOTALPRICE: Rep[Double] = oRDERSRecord_Field_O_TOTALPRICE(self)
    def O_ORDERSTATUS: Rep[Char] = oRDERSRecord_Field_O_ORDERSTATUS(self)
    def O_CUSTKEY: Rep[Int] = oRDERSRecord_Field_O_CUSTKEY(self)
    def O_ORDERKEY: Rep[Int] = oRDERSRecord_Field_O_ORDERKEY(self)
  }
  object ORDERSRecord {
    def apply(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordApplyObject(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  }
  // constructors
  def __newORDERSRecord(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  // IR defs
  val ORDERSRecordNew = ORDERSRecordIRs.ORDERSRecordNew
  type ORDERSRecordNew = ORDERSRecordIRs.ORDERSRecordNew
  val ORDERSRecordGetField = ORDERSRecordIRs.ORDERSRecordGetField
  type ORDERSRecordGetField = ORDERSRecordIRs.ORDERSRecordGetField
  val ORDERSRecord_Field_O_COMMENT = ORDERSRecordIRs.ORDERSRecord_Field_O_COMMENT
  type ORDERSRecord_Field_O_COMMENT = ORDERSRecordIRs.ORDERSRecord_Field_O_COMMENT
  val ORDERSRecord_Field_O_SHIPPRIORITY = ORDERSRecordIRs.ORDERSRecord_Field_O_SHIPPRIORITY
  type ORDERSRecord_Field_O_SHIPPRIORITY = ORDERSRecordIRs.ORDERSRecord_Field_O_SHIPPRIORITY
  val ORDERSRecord_Field_O_CLERK = ORDERSRecordIRs.ORDERSRecord_Field_O_CLERK
  type ORDERSRecord_Field_O_CLERK = ORDERSRecordIRs.ORDERSRecord_Field_O_CLERK
  val ORDERSRecord_Field_O_ORDERPRIORITY = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERPRIORITY
  type ORDERSRecord_Field_O_ORDERPRIORITY = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERPRIORITY
  val ORDERSRecord_Field_O_ORDERDATE = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERDATE
  type ORDERSRecord_Field_O_ORDERDATE = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERDATE
  val ORDERSRecord_Field_O_TOTALPRICE = ORDERSRecordIRs.ORDERSRecord_Field_O_TOTALPRICE
  type ORDERSRecord_Field_O_TOTALPRICE = ORDERSRecordIRs.ORDERSRecord_Field_O_TOTALPRICE
  val ORDERSRecord_Field_O_ORDERSTATUS = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERSTATUS
  type ORDERSRecord_Field_O_ORDERSTATUS = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERSTATUS
  val ORDERSRecord_Field_O_CUSTKEY = ORDERSRecordIRs.ORDERSRecord_Field_O_CUSTKEY
  type ORDERSRecord_Field_O_CUSTKEY = ORDERSRecordIRs.ORDERSRecord_Field_O_CUSTKEY
  val ORDERSRecord_Field_O_ORDERKEY = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERKEY
  type ORDERSRecord_Field_O_ORDERKEY = ORDERSRecordIRs.ORDERSRecord_Field_O_ORDERKEY
  // method definitions
  def oRDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = ORDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  def oRDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]): Rep[Option[Any]] = ORDERSRecordGetField(self, key)
  def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_COMMENT(self)
  def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_SHIPPRIORITY(self)
  def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_CLERK(self)
  def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_ORDERPRIORITY(self)
  def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERDATE(self)
  def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = ORDERSRecord_Field_O_TOTALPRICE(self)
  def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Char] = ORDERSRecord_Field_O_ORDERSTATUS(self)
  def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_CUSTKEY(self)
  def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERKEY(self)
  def oRDERSRecordApplyObject(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = {
    __newORDERSRecord(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  }
  type ORDERSRecord = ch.epfl.data.dblab.experimentation.tpch.ORDERSRecord
}
object ORDERSRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object ORDERSRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[ORDERSRecord](scala.reflect.runtime.universe.typeOf[ORDERSRecord]) {
    override def isRecord = true
  }
  implicit val typeORDERSRecord: TypeRep[ORDERSRecord] = ORDERSRecordType
  // case classes
  case class ORDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]) extends ConstructorDef[ORDERSRecord](List(), "ORDERSRecord", List(List(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class ORDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class ORDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_SHIPPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_SHIPPRIORITY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_CLERK") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_CLERK
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]) extends FieldDef[OptimalString](self, "O_ORDERPRIORITY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_ORDERPRIORITY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_ORDERDATE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_ORDERDATE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]) extends FieldDef[Double](self, "O_TOTALPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_TOTALPRICE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]) extends FieldDef[Char](self, "O_ORDERSTATUS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Char = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_ORDERSTATUS
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_CUSTKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ORDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]) extends FieldDef[Int](self, "O_ORDERKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[ORDERSRecord]
      self.O_ORDERKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type ORDERSRecord = ch.epfl.data.dblab.experimentation.tpch.ORDERSRecord
}
trait ORDERSRecordImplicits extends ORDERSRecordOps {
  // Add implicit conversions here!
}
trait ORDERSRecordComponent extends ORDERSRecordOps with ORDERSRecordImplicits {}

trait ORDERSRecordPartialEvaluation extends ORDERSRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = self match {
    case Def(node: ORDERSRecordNew) => node.O_COMMENT
    case _                          => super.oRDERSRecord_Field_O_COMMENT(self)
  }
  override def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_SHIPPRIORITY
    case _                          => super.oRDERSRecord_Field_O_SHIPPRIORITY(self)
  }
  override def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = self match {
    case Def(node: ORDERSRecordNew) => node.O_CLERK
    case _                          => super.oRDERSRecord_Field_O_CLERK(self)
  }
  override def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERPRIORITY
    case _                          => super.oRDERSRecord_Field_O_ORDERPRIORITY(self)
  }
  override def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERDATE
    case _                          => super.oRDERSRecord_Field_O_ORDERDATE(self)
  }
  override def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = self match {
    case Def(node: ORDERSRecordNew) => node.O_TOTALPRICE
    case _                          => super.oRDERSRecord_Field_O_TOTALPRICE(self)
  }
  override def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Char] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERSTATUS
    case _                          => super.oRDERSRecord_Field_O_ORDERSTATUS(self)
  }
  override def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_CUSTKEY
    case _                          => super.oRDERSRecord_Field_O_CUSTKEY(self)
  }
  override def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = self match {
    case Def(node: ORDERSRecordNew) => node.O_ORDERKEY
    case _                          => super.oRDERSRecord_Field_O_ORDERKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object ORDERSRecordQuasiNodes extends BaseExtIR {
  import ORDERSRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class ORDERSRecordNewExt(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]) extends FunctionDef[ORDERSRecordNew, ORDERSRecord] {
    override def nodeUnapply(t: ORDERSRecordNew): Option[Product] = (ORDERSRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecordGetFieldExt(self: Rep[ORDERSRecord], key: Rep[String]) extends FunctionDef[ORDERSRecordGetField, Option[Any]] {
    override def nodeUnapply(t: ORDERSRecordGetField): Option[Product] = (ORDERSRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_COMMENTExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_COMMENT, OptimalString] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_COMMENT): Option[Product] = (ORDERSRecord_Field_O_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_SHIPPRIORITYExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_SHIPPRIORITY, Int] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_SHIPPRIORITY): Option[Product] = (ORDERSRecord_Field_O_SHIPPRIORITY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_CLERKExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_CLERK, OptimalString] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_CLERK): Option[Product] = (ORDERSRecord_Field_O_CLERK.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_ORDERPRIORITYExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_ORDERPRIORITY, OptimalString] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_ORDERPRIORITY): Option[Product] = (ORDERSRecord_Field_O_ORDERPRIORITY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_ORDERDATEExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_ORDERDATE, Int] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_ORDERDATE): Option[Product] = (ORDERSRecord_Field_O_ORDERDATE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_TOTALPRICEExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_TOTALPRICE, Double] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_TOTALPRICE): Option[Product] = (ORDERSRecord_Field_O_TOTALPRICE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_ORDERSTATUSExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_ORDERSTATUS, Char] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_ORDERSTATUS): Option[Product] = (ORDERSRecord_Field_O_ORDERSTATUS.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_CUSTKEYExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_CUSTKEY, Int] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_CUSTKEY): Option[Product] = (ORDERSRecord_Field_O_CUSTKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class ORDERSRecord_Field_O_ORDERKEYExt(self: Rep[ORDERSRecord]) extends FunctionDef[ORDERSRecord_Field_O_ORDERKEY, Int] {
    override def nodeUnapply(t: ORDERSRecord_Field_O_ORDERKEY): Option[Product] = (ORDERSRecord_Field_O_ORDERKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type ORDERSRecord = ch.epfl.data.dblab.experimentation.tpch.ORDERSRecord
}

trait ORDERSRecordExtOps extends BaseExt with OptimalStringExtOps {

  import ORDERSRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class ORDERSRecordRep(self: Rep[ORDERSRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = oRDERSRecordGetField(self, key)
    def O_COMMENT: Rep[OptimalString] = oRDERSRecord_Field_O_COMMENT(self)
    def O_SHIPPRIORITY: Rep[Int] = oRDERSRecord_Field_O_SHIPPRIORITY(self)
    def O_CLERK: Rep[OptimalString] = oRDERSRecord_Field_O_CLERK(self)
    def O_ORDERPRIORITY: Rep[OptimalString] = oRDERSRecord_Field_O_ORDERPRIORITY(self)
    def O_ORDERDATE: Rep[Int] = oRDERSRecord_Field_O_ORDERDATE(self)
    def O_TOTALPRICE: Rep[Double] = oRDERSRecord_Field_O_TOTALPRICE(self)
    def O_ORDERSTATUS: Rep[Char] = oRDERSRecord_Field_O_ORDERSTATUS(self)
    def O_CUSTKEY: Rep[Int] = oRDERSRecord_Field_O_CUSTKEY(self)
    def O_ORDERKEY: Rep[Int] = oRDERSRecord_Field_O_ORDERKEY(self)
  }
  object ORDERSRecord {
    def apply(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordApplyObject(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  }
  // constructors
  def __newORDERSRecord(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = oRDERSRecordNew(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)

  // method definitions
  def oRDERSRecordApplyObject(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = { __newORDERSRecord(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT) }
  def oRDERSRecordNew(O_ORDERKEY: Rep[Int], O_CUSTKEY: Rep[Int], O_ORDERSTATUS: Rep[Char], O_TOTALPRICE: Rep[Double], O_ORDERDATE: Rep[Int], O_ORDERPRIORITY: Rep[OptimalString], O_CLERK: Rep[OptimalString], O_SHIPPRIORITY: Rep[Int], O_COMMENT: Rep[OptimalString]): Rep[ORDERSRecord] = ORDERSRecordNewExt(O_ORDERKEY, O_CUSTKEY, O_ORDERSTATUS, O_TOTALPRICE, O_ORDERDATE, O_ORDERPRIORITY, O_CLERK, O_SHIPPRIORITY, O_COMMENT)
  def oRDERSRecordGetField(self: Rep[ORDERSRecord], key: Rep[String]): Rep[Option[Any]] = ORDERSRecordGetFieldExt(self, key)
  def oRDERSRecord_Field_O_COMMENT(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_COMMENTExt(self)
  def oRDERSRecord_Field_O_SHIPPRIORITY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_SHIPPRIORITYExt(self)
  def oRDERSRecord_Field_O_CLERK(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_CLERKExt(self)
  def oRDERSRecord_Field_O_ORDERPRIORITY(self: Rep[ORDERSRecord]): Rep[OptimalString] = ORDERSRecord_Field_O_ORDERPRIORITYExt(self)
  def oRDERSRecord_Field_O_ORDERDATE(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERDATEExt(self)
  def oRDERSRecord_Field_O_TOTALPRICE(self: Rep[ORDERSRecord]): Rep[Double] = ORDERSRecord_Field_O_TOTALPRICEExt(self)
  def oRDERSRecord_Field_O_ORDERSTATUS(self: Rep[ORDERSRecord]): Rep[Char] = ORDERSRecord_Field_O_ORDERSTATUSExt(self)
  def oRDERSRecord_Field_O_CUSTKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_CUSTKEYExt(self)
  def oRDERSRecord_Field_O_ORDERKEY(self: Rep[ORDERSRecord]): Rep[Int] = ORDERSRecord_Field_O_ORDERKEYExt(self)
  type ORDERSRecord = ch.epfl.data.dblab.experimentation.tpch.ORDERSRecord
}

trait CUSTOMERRecordOps extends Base with OptimalStringOps {
  // Type representation
  val CUSTOMERRecordType = CUSTOMERRecordIRs.CUSTOMERRecordType
  implicit val typeCUSTOMERRecord: TypeRep[CUSTOMERRecord] = CUSTOMERRecordType
  implicit class CUSTOMERRecordRep(self: Rep[CUSTOMERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = cUSTOMERRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_COMMENT(self)
    def C_MKTSEGMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_MKTSEGMENT(self)
    def C_ACCTBAL: Rep[Double] = cUSTOMERRecord_Field_C_ACCTBAL(self)
    def C_PHONE: Rep[OptimalString] = cUSTOMERRecord_Field_C_PHONE(self)
    def C_NATIONKEY: Rep[Int] = cUSTOMERRecord_Field_C_NATIONKEY(self)
    def C_ADDRESS: Rep[OptimalString] = cUSTOMERRecord_Field_C_ADDRESS(self)
    def C_NAME: Rep[OptimalString] = cUSTOMERRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = cUSTOMERRecord_Field_C_CUSTKEY(self)
  }
  object CUSTOMERRecord {
    def apply(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordApplyObject(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  }
  // constructors
  def __newCUSTOMERRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  // IR defs
  val CUSTOMERRecordNew = CUSTOMERRecordIRs.CUSTOMERRecordNew
  type CUSTOMERRecordNew = CUSTOMERRecordIRs.CUSTOMERRecordNew
  val CUSTOMERRecordGetField = CUSTOMERRecordIRs.CUSTOMERRecordGetField
  type CUSTOMERRecordGetField = CUSTOMERRecordIRs.CUSTOMERRecordGetField
  val CUSTOMERRecord_Field_C_COMMENT = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_COMMENT
  type CUSTOMERRecord_Field_C_COMMENT = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_COMMENT
  val CUSTOMERRecord_Field_C_MKTSEGMENT = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_MKTSEGMENT
  type CUSTOMERRecord_Field_C_MKTSEGMENT = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_MKTSEGMENT
  val CUSTOMERRecord_Field_C_ACCTBAL = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_ACCTBAL
  type CUSTOMERRecord_Field_C_ACCTBAL = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_ACCTBAL
  val CUSTOMERRecord_Field_C_PHONE = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_PHONE
  type CUSTOMERRecord_Field_C_PHONE = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_PHONE
  val CUSTOMERRecord_Field_C_NATIONKEY = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_NATIONKEY
  type CUSTOMERRecord_Field_C_NATIONKEY = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_NATIONKEY
  val CUSTOMERRecord_Field_C_ADDRESS = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_ADDRESS
  type CUSTOMERRecord_Field_C_ADDRESS = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_ADDRESS
  val CUSTOMERRecord_Field_C_NAME = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_NAME
  type CUSTOMERRecord_Field_C_NAME = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_NAME
  val CUSTOMERRecord_Field_C_CUSTKEY = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_CUSTKEY
  type CUSTOMERRecord_Field_C_CUSTKEY = CUSTOMERRecordIRs.CUSTOMERRecord_Field_C_CUSTKEY
  // method definitions
  def cUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = CUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  def cUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]): Rep[Option[Any]] = CUSTOMERRecordGetField(self, key)
  def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_COMMENT(self)
  def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_MKTSEGMENT(self)
  def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = CUSTOMERRecord_Field_C_ACCTBAL(self)
  def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_PHONE(self)
  def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_NATIONKEY(self)
  def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_ADDRESS(self)
  def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_NAME(self)
  def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_CUSTKEY(self)
  def cUSTOMERRecordApplyObject(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = {
    __newCUSTOMERRecord(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  }
  type CUSTOMERRecord = ch.epfl.data.dblab.experimentation.tpch.CUSTOMERRecord
}
object CUSTOMERRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object CUSTOMERRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[CUSTOMERRecord](scala.reflect.runtime.universe.typeOf[CUSTOMERRecord]) {
    override def isRecord = true
  }
  implicit val typeCUSTOMERRecord: TypeRep[CUSTOMERRecord] = CUSTOMERRecordType
  // case classes
  case class CUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends ConstructorDef[CUSTOMERRecord](List(), "CUSTOMERRecord", List(List(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class CUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class CUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_MKTSEGMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_MKTSEGMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]) extends FieldDef[Double](self, "C_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_ACCTBAL
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_PHONE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_NATIONKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_ADDRESS
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]) extends FieldDef[OptimalString](self, "C_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_NAME
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class CUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]) extends FieldDef[Int](self, "C_CUSTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[CUSTOMERRecord]
      self.C_CUSTKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type CUSTOMERRecord = ch.epfl.data.dblab.experimentation.tpch.CUSTOMERRecord
}
trait CUSTOMERRecordImplicits extends CUSTOMERRecordOps {
  // Add implicit conversions here!
}
trait CUSTOMERRecordComponent extends CUSTOMERRecordOps with CUSTOMERRecordImplicits {}

trait CUSTOMERRecordPartialEvaluation extends CUSTOMERRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_COMMENT
    case _                            => super.cUSTOMERRecord_Field_C_COMMENT(self)
  }
  override def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_MKTSEGMENT
    case _                            => super.cUSTOMERRecord_Field_C_MKTSEGMENT(self)
  }
  override def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_ACCTBAL
    case _                            => super.cUSTOMERRecord_Field_C_ACCTBAL(self)
  }
  override def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_PHONE
    case _                            => super.cUSTOMERRecord_Field_C_PHONE(self)
  }
  override def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_NATIONKEY
    case _                            => super.cUSTOMERRecord_Field_C_NATIONKEY(self)
  }
  override def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_ADDRESS
    case _                            => super.cUSTOMERRecord_Field_C_ADDRESS(self)
  }
  override def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_NAME
    case _                            => super.cUSTOMERRecord_Field_C_NAME(self)
  }
  override def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = self match {
    case Def(node: CUSTOMERRecordNew) => node.C_CUSTKEY
    case _                            => super.cUSTOMERRecord_Field_C_CUSTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object CUSTOMERRecordQuasiNodes extends BaseExtIR {
  import CUSTOMERRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class CUSTOMERRecordNewExt(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]) extends FunctionDef[CUSTOMERRecordNew, CUSTOMERRecord] {
    override def nodeUnapply(t: CUSTOMERRecordNew): Option[Product] = (CUSTOMERRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecordGetFieldExt(self: Rep[CUSTOMERRecord], key: Rep[String]) extends FunctionDef[CUSTOMERRecordGetField, Option[Any]] {
    override def nodeUnapply(t: CUSTOMERRecordGetField): Option[Product] = (CUSTOMERRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_COMMENTExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_COMMENT, OptimalString] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_COMMENT): Option[Product] = (CUSTOMERRecord_Field_C_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_MKTSEGMENTExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_MKTSEGMENT, OptimalString] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_MKTSEGMENT): Option[Product] = (CUSTOMERRecord_Field_C_MKTSEGMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_ACCTBALExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_ACCTBAL, Double] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_ACCTBAL): Option[Product] = (CUSTOMERRecord_Field_C_ACCTBAL.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_PHONEExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_PHONE, OptimalString] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_PHONE): Option[Product] = (CUSTOMERRecord_Field_C_PHONE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_NATIONKEYExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_NATIONKEY, Int] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_NATIONKEY): Option[Product] = (CUSTOMERRecord_Field_C_NATIONKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_ADDRESSExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_ADDRESS, OptimalString] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_ADDRESS): Option[Product] = (CUSTOMERRecord_Field_C_ADDRESS.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_NAMEExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_NAME, OptimalString] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_NAME): Option[Product] = (CUSTOMERRecord_Field_C_NAME.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class CUSTOMERRecord_Field_C_CUSTKEYExt(self: Rep[CUSTOMERRecord]) extends FunctionDef[CUSTOMERRecord_Field_C_CUSTKEY, Int] {
    override def nodeUnapply(t: CUSTOMERRecord_Field_C_CUSTKEY): Option[Product] = (CUSTOMERRecord_Field_C_CUSTKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type CUSTOMERRecord = ch.epfl.data.dblab.experimentation.tpch.CUSTOMERRecord
}

trait CUSTOMERRecordExtOps extends BaseExt with OptimalStringExtOps {

  import CUSTOMERRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class CUSTOMERRecordRep(self: Rep[CUSTOMERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = cUSTOMERRecordGetField(self, key)
    def C_COMMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_COMMENT(self)
    def C_MKTSEGMENT: Rep[OptimalString] = cUSTOMERRecord_Field_C_MKTSEGMENT(self)
    def C_ACCTBAL: Rep[Double] = cUSTOMERRecord_Field_C_ACCTBAL(self)
    def C_PHONE: Rep[OptimalString] = cUSTOMERRecord_Field_C_PHONE(self)
    def C_NATIONKEY: Rep[Int] = cUSTOMERRecord_Field_C_NATIONKEY(self)
    def C_ADDRESS: Rep[OptimalString] = cUSTOMERRecord_Field_C_ADDRESS(self)
    def C_NAME: Rep[OptimalString] = cUSTOMERRecord_Field_C_NAME(self)
    def C_CUSTKEY: Rep[Int] = cUSTOMERRecord_Field_C_CUSTKEY(self)
  }
  object CUSTOMERRecord {
    def apply(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordApplyObject(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  }
  // constructors
  def __newCUSTOMERRecord(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = cUSTOMERRecordNew(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)

  // method definitions
  def cUSTOMERRecordApplyObject(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = { __newCUSTOMERRecord(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT) }
  def cUSTOMERRecordNew(C_CUSTKEY: Rep[Int], C_NAME: Rep[OptimalString], C_ADDRESS: Rep[OptimalString], C_NATIONKEY: Rep[Int], C_PHONE: Rep[OptimalString], C_ACCTBAL: Rep[Double], C_MKTSEGMENT: Rep[OptimalString], C_COMMENT: Rep[OptimalString]): Rep[CUSTOMERRecord] = CUSTOMERRecordNewExt(C_CUSTKEY, C_NAME, C_ADDRESS, C_NATIONKEY, C_PHONE, C_ACCTBAL, C_MKTSEGMENT, C_COMMENT)
  def cUSTOMERRecordGetField(self: Rep[CUSTOMERRecord], key: Rep[String]): Rep[Option[Any]] = CUSTOMERRecordGetFieldExt(self, key)
  def cUSTOMERRecord_Field_C_COMMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_COMMENTExt(self)
  def cUSTOMERRecord_Field_C_MKTSEGMENT(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_MKTSEGMENTExt(self)
  def cUSTOMERRecord_Field_C_ACCTBAL(self: Rep[CUSTOMERRecord]): Rep[Double] = CUSTOMERRecord_Field_C_ACCTBALExt(self)
  def cUSTOMERRecord_Field_C_PHONE(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_PHONEExt(self)
  def cUSTOMERRecord_Field_C_NATIONKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_NATIONKEYExt(self)
  def cUSTOMERRecord_Field_C_ADDRESS(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_ADDRESSExt(self)
  def cUSTOMERRecord_Field_C_NAME(self: Rep[CUSTOMERRecord]): Rep[OptimalString] = CUSTOMERRecord_Field_C_NAMEExt(self)
  def cUSTOMERRecord_Field_C_CUSTKEY(self: Rep[CUSTOMERRecord]): Rep[Int] = CUSTOMERRecord_Field_C_CUSTKEYExt(self)
  type CUSTOMERRecord = ch.epfl.data.dblab.experimentation.tpch.CUSTOMERRecord
}

trait SUPPLIERRecordOps extends Base with OptimalStringOps {
  // Type representation
  val SUPPLIERRecordType = SUPPLIERRecordIRs.SUPPLIERRecordType
  implicit val typeSUPPLIERRecord: TypeRep[SUPPLIERRecord] = SUPPLIERRecordType
  implicit class SUPPLIERRecordRep(self: Rep[SUPPLIERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = sUPPLIERRecordGetField(self, key)
    def S_COMMENT: Rep[OptimalString] = sUPPLIERRecord_Field_S_COMMENT(self)
    def S_ACCTBAL: Rep[Double] = sUPPLIERRecord_Field_S_ACCTBAL(self)
    def S_PHONE: Rep[OptimalString] = sUPPLIERRecord_Field_S_PHONE(self)
    def S_NATIONKEY: Rep[Int] = sUPPLIERRecord_Field_S_NATIONKEY(self)
    def S_ADDRESS: Rep[OptimalString] = sUPPLIERRecord_Field_S_ADDRESS(self)
    def S_NAME: Rep[OptimalString] = sUPPLIERRecord_Field_S_NAME(self)
    def S_SUPPKEY: Rep[Int] = sUPPLIERRecord_Field_S_SUPPKEY(self)
  }
  object SUPPLIERRecord {
    def apply(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordApplyObject(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  }
  // constructors
  def __newSUPPLIERRecord(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  // IR defs
  val SUPPLIERRecordNew = SUPPLIERRecordIRs.SUPPLIERRecordNew
  type SUPPLIERRecordNew = SUPPLIERRecordIRs.SUPPLIERRecordNew
  val SUPPLIERRecordGetField = SUPPLIERRecordIRs.SUPPLIERRecordGetField
  type SUPPLIERRecordGetField = SUPPLIERRecordIRs.SUPPLIERRecordGetField
  val SUPPLIERRecord_Field_S_COMMENT = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_COMMENT
  type SUPPLIERRecord_Field_S_COMMENT = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_COMMENT
  val SUPPLIERRecord_Field_S_ACCTBAL = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_ACCTBAL
  type SUPPLIERRecord_Field_S_ACCTBAL = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_ACCTBAL
  val SUPPLIERRecord_Field_S_PHONE = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_PHONE
  type SUPPLIERRecord_Field_S_PHONE = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_PHONE
  val SUPPLIERRecord_Field_S_NATIONKEY = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_NATIONKEY
  type SUPPLIERRecord_Field_S_NATIONKEY = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_NATIONKEY
  val SUPPLIERRecord_Field_S_ADDRESS = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_ADDRESS
  type SUPPLIERRecord_Field_S_ADDRESS = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_ADDRESS
  val SUPPLIERRecord_Field_S_NAME = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_NAME
  type SUPPLIERRecord_Field_S_NAME = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_NAME
  val SUPPLIERRecord_Field_S_SUPPKEY = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_SUPPKEY
  type SUPPLIERRecord_Field_S_SUPPKEY = SUPPLIERRecordIRs.SUPPLIERRecord_Field_S_SUPPKEY
  // method definitions
  def sUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = SUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  def sUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]): Rep[Option[Any]] = SUPPLIERRecordGetField(self, key)
  def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_COMMENT(self)
  def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = SUPPLIERRecord_Field_S_ACCTBAL(self)
  def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_PHONE(self)
  def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_NATIONKEY(self)
  def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_ADDRESS(self)
  def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_NAME(self)
  def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_SUPPKEY(self)
  def sUPPLIERRecordApplyObject(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = {
    __newSUPPLIERRecord(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  }
  type SUPPLIERRecord = ch.epfl.data.dblab.experimentation.tpch.SUPPLIERRecord
}
object SUPPLIERRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object SUPPLIERRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[SUPPLIERRecord](scala.reflect.runtime.universe.typeOf[SUPPLIERRecord]) {
    override def isRecord = true
  }
  implicit val typeSUPPLIERRecord: TypeRep[SUPPLIERRecord] = SUPPLIERRecordType
  // case classes
  case class SUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]) extends ConstructorDef[SUPPLIERRecord](List(), "SUPPLIERRecord", List(List(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class SUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class SUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]) extends FieldDef[Double](self, "S_ACCTBAL") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_ACCTBAL
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_PHONE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_PHONE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_NATIONKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_ADDRESS") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_ADDRESS
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]) extends FieldDef[OptimalString](self, "S_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_NAME
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]) extends FieldDef[Int](self, "S_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[SUPPLIERRecord]
      self.S_SUPPKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type SUPPLIERRecord = ch.epfl.data.dblab.experimentation.tpch.SUPPLIERRecord
}
trait SUPPLIERRecordImplicits extends SUPPLIERRecordOps {
  // Add implicit conversions here!
}
trait SUPPLIERRecordComponent extends SUPPLIERRecordOps with SUPPLIERRecordImplicits {}

trait SUPPLIERRecordPartialEvaluation extends SUPPLIERRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_COMMENT
    case _                            => super.sUPPLIERRecord_Field_S_COMMENT(self)
  }
  override def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_ACCTBAL
    case _                            => super.sUPPLIERRecord_Field_S_ACCTBAL(self)
  }
  override def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_PHONE
    case _                            => super.sUPPLIERRecord_Field_S_PHONE(self)
  }
  override def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_NATIONKEY
    case _                            => super.sUPPLIERRecord_Field_S_NATIONKEY(self)
  }
  override def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_ADDRESS
    case _                            => super.sUPPLIERRecord_Field_S_ADDRESS(self)
  }
  override def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_NAME
    case _                            => super.sUPPLIERRecord_Field_S_NAME(self)
  }
  override def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = self match {
    case Def(node: SUPPLIERRecordNew) => node.S_SUPPKEY
    case _                            => super.sUPPLIERRecord_Field_S_SUPPKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object SUPPLIERRecordQuasiNodes extends BaseExtIR {
  import SUPPLIERRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class SUPPLIERRecordNewExt(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]) extends FunctionDef[SUPPLIERRecordNew, SUPPLIERRecord] {
    override def nodeUnapply(t: SUPPLIERRecordNew): Option[Product] = (SUPPLIERRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecordGetFieldExt(self: Rep[SUPPLIERRecord], key: Rep[String]) extends FunctionDef[SUPPLIERRecordGetField, Option[Any]] {
    override def nodeUnapply(t: SUPPLIERRecordGetField): Option[Product] = (SUPPLIERRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_COMMENTExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_COMMENT, OptimalString] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_COMMENT): Option[Product] = (SUPPLIERRecord_Field_S_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_ACCTBALExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_ACCTBAL, Double] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_ACCTBAL): Option[Product] = (SUPPLIERRecord_Field_S_ACCTBAL.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_PHONEExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_PHONE, OptimalString] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_PHONE): Option[Product] = (SUPPLIERRecord_Field_S_PHONE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_NATIONKEYExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_NATIONKEY, Int] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_NATIONKEY): Option[Product] = (SUPPLIERRecord_Field_S_NATIONKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_ADDRESSExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_ADDRESS, OptimalString] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_ADDRESS): Option[Product] = (SUPPLIERRecord_Field_S_ADDRESS.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_NAMEExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_NAME, OptimalString] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_NAME): Option[Product] = (SUPPLIERRecord_Field_S_NAME.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class SUPPLIERRecord_Field_S_SUPPKEYExt(self: Rep[SUPPLIERRecord]) extends FunctionDef[SUPPLIERRecord_Field_S_SUPPKEY, Int] {
    override def nodeUnapply(t: SUPPLIERRecord_Field_S_SUPPKEY): Option[Product] = (SUPPLIERRecord_Field_S_SUPPKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type SUPPLIERRecord = ch.epfl.data.dblab.experimentation.tpch.SUPPLIERRecord
}

trait SUPPLIERRecordExtOps extends BaseExt with OptimalStringExtOps {

  import SUPPLIERRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class SUPPLIERRecordRep(self: Rep[SUPPLIERRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = sUPPLIERRecordGetField(self, key)
    def S_COMMENT: Rep[OptimalString] = sUPPLIERRecord_Field_S_COMMENT(self)
    def S_ACCTBAL: Rep[Double] = sUPPLIERRecord_Field_S_ACCTBAL(self)
    def S_PHONE: Rep[OptimalString] = sUPPLIERRecord_Field_S_PHONE(self)
    def S_NATIONKEY: Rep[Int] = sUPPLIERRecord_Field_S_NATIONKEY(self)
    def S_ADDRESS: Rep[OptimalString] = sUPPLIERRecord_Field_S_ADDRESS(self)
    def S_NAME: Rep[OptimalString] = sUPPLIERRecord_Field_S_NAME(self)
    def S_SUPPKEY: Rep[Int] = sUPPLIERRecord_Field_S_SUPPKEY(self)
  }
  object SUPPLIERRecord {
    def apply(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordApplyObject(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  }
  // constructors
  def __newSUPPLIERRecord(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = sUPPLIERRecordNew(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)

  // method definitions
  def sUPPLIERRecordApplyObject(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = { __newSUPPLIERRecord(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT) }
  def sUPPLIERRecordNew(S_SUPPKEY: Rep[Int], S_NAME: Rep[OptimalString], S_ADDRESS: Rep[OptimalString], S_NATIONKEY: Rep[Int], S_PHONE: Rep[OptimalString], S_ACCTBAL: Rep[Double], S_COMMENT: Rep[OptimalString]): Rep[SUPPLIERRecord] = SUPPLIERRecordNewExt(S_SUPPKEY, S_NAME, S_ADDRESS, S_NATIONKEY, S_PHONE, S_ACCTBAL, S_COMMENT)
  def sUPPLIERRecordGetField(self: Rep[SUPPLIERRecord], key: Rep[String]): Rep[Option[Any]] = SUPPLIERRecordGetFieldExt(self, key)
  def sUPPLIERRecord_Field_S_COMMENT(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_COMMENTExt(self)
  def sUPPLIERRecord_Field_S_ACCTBAL(self: Rep[SUPPLIERRecord]): Rep[Double] = SUPPLIERRecord_Field_S_ACCTBALExt(self)
  def sUPPLIERRecord_Field_S_PHONE(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_PHONEExt(self)
  def sUPPLIERRecord_Field_S_NATIONKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_NATIONKEYExt(self)
  def sUPPLIERRecord_Field_S_ADDRESS(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_ADDRESSExt(self)
  def sUPPLIERRecord_Field_S_NAME(self: Rep[SUPPLIERRecord]): Rep[OptimalString] = SUPPLIERRecord_Field_S_NAMEExt(self)
  def sUPPLIERRecord_Field_S_SUPPKEY(self: Rep[SUPPLIERRecord]): Rep[Int] = SUPPLIERRecord_Field_S_SUPPKEYExt(self)
  type SUPPLIERRecord = ch.epfl.data.dblab.experimentation.tpch.SUPPLIERRecord
}

trait PARTSUPPRecordOps extends Base with OptimalStringOps {
  // Type representation
  val PARTSUPPRecordType = PARTSUPPRecordIRs.PARTSUPPRecordType
  implicit val typePARTSUPPRecord: TypeRep[PARTSUPPRecord] = PARTSUPPRecordType
  implicit class PARTSUPPRecordRep(self: Rep[PARTSUPPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTSUPPRecordGetField(self, key)
    def PS_COMMENT: Rep[OptimalString] = pARTSUPPRecord_Field_PS_COMMENT(self)
    def PS_SUPPLYCOST: Rep[Double] = pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
    def PS_AVAILQTY: Rep[Int] = pARTSUPPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = pARTSUPPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = pARTSUPPRecord_Field_PS_PARTKEY(self)
  }
  object PARTSUPPRecord {
    def apply(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordApplyObject(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  }
  // constructors
  def __newPARTSUPPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  // IR defs
  val PARTSUPPRecordNew = PARTSUPPRecordIRs.PARTSUPPRecordNew
  type PARTSUPPRecordNew = PARTSUPPRecordIRs.PARTSUPPRecordNew
  val PARTSUPPRecordGetField = PARTSUPPRecordIRs.PARTSUPPRecordGetField
  type PARTSUPPRecordGetField = PARTSUPPRecordIRs.PARTSUPPRecordGetField
  val PARTSUPPRecord_Field_PS_COMMENT = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_COMMENT
  type PARTSUPPRecord_Field_PS_COMMENT = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_COMMENT
  val PARTSUPPRecord_Field_PS_SUPPLYCOST = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_SUPPLYCOST
  type PARTSUPPRecord_Field_PS_SUPPLYCOST = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_SUPPLYCOST
  val PARTSUPPRecord_Field_PS_AVAILQTY = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_AVAILQTY
  type PARTSUPPRecord_Field_PS_AVAILQTY = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_AVAILQTY
  val PARTSUPPRecord_Field_PS_SUPPKEY = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_SUPPKEY
  type PARTSUPPRecord_Field_PS_SUPPKEY = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_SUPPKEY
  val PARTSUPPRecord_Field_PS_PARTKEY = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_PARTKEY
  type PARTSUPPRecord_Field_PS_PARTKEY = PARTSUPPRecordIRs.PARTSUPPRecord_Field_PS_PARTKEY
  // method definitions
  def pARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = PARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  def pARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]): Rep[Option[Any]] = PARTSUPPRecordGetField(self, key)
  def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = PARTSUPPRecord_Field_PS_COMMENT(self)
  def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = PARTSUPPRecord_Field_PS_SUPPLYCOST(self)
  def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_AVAILQTY(self)
  def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_SUPPKEY(self)
  def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_PARTKEY(self)
  def pARTSUPPRecordApplyObject(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = {
    __newPARTSUPPRecord(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  }
  type PARTSUPPRecord = ch.epfl.data.dblab.experimentation.tpch.PARTSUPPRecord
}
object PARTSUPPRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object PARTSUPPRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[PARTSUPPRecord](scala.reflect.runtime.universe.typeOf[PARTSUPPRecord]) {
    override def isRecord = true
  }
  implicit val typePARTSUPPRecord: TypeRep[PARTSUPPRecord] = PARTSUPPRecordType
  // case classes
  case class PARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTSUPPRecord](List(), "PARTSUPPRecord", List(List(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class PARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]) extends FieldDef[OptimalString](self, "PS_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTSUPPRecord]
      self.PS_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]) extends FieldDef[Double](self, "PS_SUPPLYCOST") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[PARTSUPPRecord]
      self.PS_SUPPLYCOST
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_AVAILQTY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[PARTSUPPRecord]
      self.PS_AVAILQTY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_SUPPKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[PARTSUPPRecord]
      self.PS_SUPPKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]) extends FieldDef[Int](self, "PS_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[PARTSUPPRecord]
      self.PS_PARTKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type PARTSUPPRecord = ch.epfl.data.dblab.experimentation.tpch.PARTSUPPRecord
}
trait PARTSUPPRecordImplicits extends PARTSUPPRecordOps {
  // Add implicit conversions here!
}
trait PARTSUPPRecordComponent extends PARTSUPPRecordOps with PARTSUPPRecordImplicits {}

trait PARTSUPPRecordPartialEvaluation extends PARTSUPPRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_COMMENT
    case _                            => super.pARTSUPPRecord_Field_PS_COMMENT(self)
  }
  override def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_SUPPLYCOST
    case _                            => super.pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
  }
  override def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_AVAILQTY
    case _                            => super.pARTSUPPRecord_Field_PS_AVAILQTY(self)
  }
  override def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_SUPPKEY
    case _                            => super.pARTSUPPRecord_Field_PS_SUPPKEY(self)
  }
  override def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = self match {
    case Def(node: PARTSUPPRecordNew) => node.PS_PARTKEY
    case _                            => super.pARTSUPPRecord_Field_PS_PARTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object PARTSUPPRecordQuasiNodes extends BaseExtIR {
  import PARTSUPPRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class PARTSUPPRecordNewExt(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]) extends FunctionDef[PARTSUPPRecordNew, PARTSUPPRecord] {
    override def nodeUnapply(t: PARTSUPPRecordNew): Option[Product] = (PARTSUPPRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTSUPPRecordGetFieldExt(self: Rep[PARTSUPPRecord], key: Rep[String]) extends FunctionDef[PARTSUPPRecordGetField, Option[Any]] {
    override def nodeUnapply(t: PARTSUPPRecordGetField): Option[Product] = (PARTSUPPRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTSUPPRecord_Field_PS_COMMENTExt(self: Rep[PARTSUPPRecord]) extends FunctionDef[PARTSUPPRecord_Field_PS_COMMENT, OptimalString] {
    override def nodeUnapply(t: PARTSUPPRecord_Field_PS_COMMENT): Option[Product] = (PARTSUPPRecord_Field_PS_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTSUPPRecord_Field_PS_SUPPLYCOSTExt(self: Rep[PARTSUPPRecord]) extends FunctionDef[PARTSUPPRecord_Field_PS_SUPPLYCOST, Double] {
    override def nodeUnapply(t: PARTSUPPRecord_Field_PS_SUPPLYCOST): Option[Product] = (PARTSUPPRecord_Field_PS_SUPPLYCOST.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTSUPPRecord_Field_PS_AVAILQTYExt(self: Rep[PARTSUPPRecord]) extends FunctionDef[PARTSUPPRecord_Field_PS_AVAILQTY, Int] {
    override def nodeUnapply(t: PARTSUPPRecord_Field_PS_AVAILQTY): Option[Product] = (PARTSUPPRecord_Field_PS_AVAILQTY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTSUPPRecord_Field_PS_SUPPKEYExt(self: Rep[PARTSUPPRecord]) extends FunctionDef[PARTSUPPRecord_Field_PS_SUPPKEY, Int] {
    override def nodeUnapply(t: PARTSUPPRecord_Field_PS_SUPPKEY): Option[Product] = (PARTSUPPRecord_Field_PS_SUPPKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTSUPPRecord_Field_PS_PARTKEYExt(self: Rep[PARTSUPPRecord]) extends FunctionDef[PARTSUPPRecord_Field_PS_PARTKEY, Int] {
    override def nodeUnapply(t: PARTSUPPRecord_Field_PS_PARTKEY): Option[Product] = (PARTSUPPRecord_Field_PS_PARTKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type PARTSUPPRecord = ch.epfl.data.dblab.experimentation.tpch.PARTSUPPRecord
}

trait PARTSUPPRecordExtOps extends BaseExt with OptimalStringExtOps {

  import PARTSUPPRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class PARTSUPPRecordRep(self: Rep[PARTSUPPRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTSUPPRecordGetField(self, key)
    def PS_COMMENT: Rep[OptimalString] = pARTSUPPRecord_Field_PS_COMMENT(self)
    def PS_SUPPLYCOST: Rep[Double] = pARTSUPPRecord_Field_PS_SUPPLYCOST(self)
    def PS_AVAILQTY: Rep[Int] = pARTSUPPRecord_Field_PS_AVAILQTY(self)
    def PS_SUPPKEY: Rep[Int] = pARTSUPPRecord_Field_PS_SUPPKEY(self)
    def PS_PARTKEY: Rep[Int] = pARTSUPPRecord_Field_PS_PARTKEY(self)
  }
  object PARTSUPPRecord {
    def apply(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordApplyObject(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  }
  // constructors
  def __newPARTSUPPRecord(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = pARTSUPPRecordNew(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)

  // method definitions
  def pARTSUPPRecordApplyObject(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = { __newPARTSUPPRecord(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT) }
  def pARTSUPPRecordNew(PS_PARTKEY: Rep[Int], PS_SUPPKEY: Rep[Int], PS_AVAILQTY: Rep[Int], PS_SUPPLYCOST: Rep[Double], PS_COMMENT: Rep[OptimalString]): Rep[PARTSUPPRecord] = PARTSUPPRecordNewExt(PS_PARTKEY, PS_SUPPKEY, PS_AVAILQTY, PS_SUPPLYCOST, PS_COMMENT)
  def pARTSUPPRecordGetField(self: Rep[PARTSUPPRecord], key: Rep[String]): Rep[Option[Any]] = PARTSUPPRecordGetFieldExt(self, key)
  def pARTSUPPRecord_Field_PS_COMMENT(self: Rep[PARTSUPPRecord]): Rep[OptimalString] = PARTSUPPRecord_Field_PS_COMMENTExt(self)
  def pARTSUPPRecord_Field_PS_SUPPLYCOST(self: Rep[PARTSUPPRecord]): Rep[Double] = PARTSUPPRecord_Field_PS_SUPPLYCOSTExt(self)
  def pARTSUPPRecord_Field_PS_AVAILQTY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_AVAILQTYExt(self)
  def pARTSUPPRecord_Field_PS_SUPPKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_SUPPKEYExt(self)
  def pARTSUPPRecord_Field_PS_PARTKEY(self: Rep[PARTSUPPRecord]): Rep[Int] = PARTSUPPRecord_Field_PS_PARTKEYExt(self)
  type PARTSUPPRecord = ch.epfl.data.dblab.experimentation.tpch.PARTSUPPRecord
}

trait REGIONRecordOps extends Base with OptimalStringOps {
  // Type representation
  val REGIONRecordType = REGIONRecordIRs.REGIONRecordType
  implicit val typeREGIONRecord: TypeRep[REGIONRecord] = REGIONRecordType
  implicit class REGIONRecordRep(self: Rep[REGIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = rEGIONRecordGetField(self, key)
    def R_COMMENT: Rep[OptimalString] = rEGIONRecord_Field_R_COMMENT(self)
    def R_NAME: Rep[OptimalString] = rEGIONRecord_Field_R_NAME(self)
    def R_REGIONKEY: Rep[Int] = rEGIONRecord_Field_R_REGIONKEY(self)
  }
  object REGIONRecord {
    def apply(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordApplyObject(R_REGIONKEY, R_NAME, R_COMMENT)
  }
  // constructors
  def __newREGIONRecord(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  // IR defs
  val REGIONRecordNew = REGIONRecordIRs.REGIONRecordNew
  type REGIONRecordNew = REGIONRecordIRs.REGIONRecordNew
  val REGIONRecordGetField = REGIONRecordIRs.REGIONRecordGetField
  type REGIONRecordGetField = REGIONRecordIRs.REGIONRecordGetField
  val REGIONRecord_Field_R_COMMENT = REGIONRecordIRs.REGIONRecord_Field_R_COMMENT
  type REGIONRecord_Field_R_COMMENT = REGIONRecordIRs.REGIONRecord_Field_R_COMMENT
  val REGIONRecord_Field_R_NAME = REGIONRecordIRs.REGIONRecord_Field_R_NAME
  type REGIONRecord_Field_R_NAME = REGIONRecordIRs.REGIONRecord_Field_R_NAME
  val REGIONRecord_Field_R_REGIONKEY = REGIONRecordIRs.REGIONRecord_Field_R_REGIONKEY
  type REGIONRecord_Field_R_REGIONKEY = REGIONRecordIRs.REGIONRecord_Field_R_REGIONKEY
  // method definitions
  def rEGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = REGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)
  def rEGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]): Rep[Option[Any]] = REGIONRecordGetField(self, key)
  def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_COMMENT(self)
  def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_NAME(self)
  def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = REGIONRecord_Field_R_REGIONKEY(self)
  def rEGIONRecordApplyObject(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = {
    __newREGIONRecord(R_REGIONKEY, R_NAME, R_COMMENT)
  }
  type REGIONRecord = ch.epfl.data.dblab.experimentation.tpch.REGIONRecord
}
object REGIONRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object REGIONRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[REGIONRecord](scala.reflect.runtime.universe.typeOf[REGIONRecord]) {
    override def isRecord = true
  }
  implicit val typeREGIONRecord: TypeRep[REGIONRecord] = REGIONRecordType
  // case classes
  case class REGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]) extends ConstructorDef[REGIONRecord](List(), "REGIONRecord", List(List(R_REGIONKEY, R_NAME, R_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class REGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class REGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[REGIONRecord]
      self.R_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class REGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]) extends FieldDef[OptimalString](self, "R_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[REGIONRecord]
      self.R_NAME
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class REGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]) extends FieldDef[Int](self, "R_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[REGIONRecord]
      self.R_REGIONKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type REGIONRecord = ch.epfl.data.dblab.experimentation.tpch.REGIONRecord
}
trait REGIONRecordImplicits extends REGIONRecordOps {
  // Add implicit conversions here!
}
trait REGIONRecordComponent extends REGIONRecordOps with REGIONRecordImplicits {}

trait REGIONRecordPartialEvaluation extends REGIONRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = self match {
    case Def(node: REGIONRecordNew) => node.R_COMMENT
    case _                          => super.rEGIONRecord_Field_R_COMMENT(self)
  }
  override def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = self match {
    case Def(node: REGIONRecordNew) => node.R_NAME
    case _                          => super.rEGIONRecord_Field_R_NAME(self)
  }
  override def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = self match {
    case Def(node: REGIONRecordNew) => node.R_REGIONKEY
    case _                          => super.rEGIONRecord_Field_R_REGIONKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object REGIONRecordQuasiNodes extends BaseExtIR {
  import REGIONRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class REGIONRecordNewExt(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]) extends FunctionDef[REGIONRecordNew, REGIONRecord] {
    override def nodeUnapply(t: REGIONRecordNew): Option[Product] = (REGIONRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class REGIONRecordGetFieldExt(self: Rep[REGIONRecord], key: Rep[String]) extends FunctionDef[REGIONRecordGetField, Option[Any]] {
    override def nodeUnapply(t: REGIONRecordGetField): Option[Product] = (REGIONRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class REGIONRecord_Field_R_COMMENTExt(self: Rep[REGIONRecord]) extends FunctionDef[REGIONRecord_Field_R_COMMENT, OptimalString] {
    override def nodeUnapply(t: REGIONRecord_Field_R_COMMENT): Option[Product] = (REGIONRecord_Field_R_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class REGIONRecord_Field_R_NAMEExt(self: Rep[REGIONRecord]) extends FunctionDef[REGIONRecord_Field_R_NAME, OptimalString] {
    override def nodeUnapply(t: REGIONRecord_Field_R_NAME): Option[Product] = (REGIONRecord_Field_R_NAME.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class REGIONRecord_Field_R_REGIONKEYExt(self: Rep[REGIONRecord]) extends FunctionDef[REGIONRecord_Field_R_REGIONKEY, Int] {
    override def nodeUnapply(t: REGIONRecord_Field_R_REGIONKEY): Option[Product] = (REGIONRecord_Field_R_REGIONKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type REGIONRecord = ch.epfl.data.dblab.experimentation.tpch.REGIONRecord
}

trait REGIONRecordExtOps extends BaseExt with OptimalStringExtOps {

  import REGIONRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class REGIONRecordRep(self: Rep[REGIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = rEGIONRecordGetField(self, key)
    def R_COMMENT: Rep[OptimalString] = rEGIONRecord_Field_R_COMMENT(self)
    def R_NAME: Rep[OptimalString] = rEGIONRecord_Field_R_NAME(self)
    def R_REGIONKEY: Rep[Int] = rEGIONRecord_Field_R_REGIONKEY(self)
  }
  object REGIONRecord {
    def apply(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordApplyObject(R_REGIONKEY, R_NAME, R_COMMENT)
  }
  // constructors
  def __newREGIONRecord(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = rEGIONRecordNew(R_REGIONKEY, R_NAME, R_COMMENT)

  // method definitions
  def rEGIONRecordApplyObject(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = { __newREGIONRecord(R_REGIONKEY, R_NAME, R_COMMENT) }
  def rEGIONRecordNew(R_REGIONKEY: Rep[Int], R_NAME: Rep[OptimalString], R_COMMENT: Rep[OptimalString]): Rep[REGIONRecord] = REGIONRecordNewExt(R_REGIONKEY, R_NAME, R_COMMENT)
  def rEGIONRecordGetField(self: Rep[REGIONRecord], key: Rep[String]): Rep[Option[Any]] = REGIONRecordGetFieldExt(self, key)
  def rEGIONRecord_Field_R_COMMENT(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_COMMENTExt(self)
  def rEGIONRecord_Field_R_NAME(self: Rep[REGIONRecord]): Rep[OptimalString] = REGIONRecord_Field_R_NAMEExt(self)
  def rEGIONRecord_Field_R_REGIONKEY(self: Rep[REGIONRecord]): Rep[Int] = REGIONRecord_Field_R_REGIONKEYExt(self)
  type REGIONRecord = ch.epfl.data.dblab.experimentation.tpch.REGIONRecord
}

trait NATIONRecordOps extends Base with OptimalStringOps {
  // Type representation
  val NATIONRecordType = NATIONRecordIRs.NATIONRecordType
  implicit val typeNATIONRecord: TypeRep[NATIONRecord] = NATIONRecordType
  implicit class NATIONRecordRep(self: Rep[NATIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = nATIONRecordGetField(self, key)
    def N_COMMENT: Rep[OptimalString] = nATIONRecord_Field_N_COMMENT(self)
    def N_REGIONKEY: Rep[Int] = nATIONRecord_Field_N_REGIONKEY(self)
    def N_NAME: Rep[OptimalString] = nATIONRecord_Field_N_NAME(self)
    def N_NATIONKEY: Rep[Int] = nATIONRecord_Field_N_NATIONKEY(self)
  }
  object NATIONRecord {
    def apply(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordApplyObject(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  }
  // constructors
  def __newNATIONRecord(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  // IR defs
  val NATIONRecordNew = NATIONRecordIRs.NATIONRecordNew
  type NATIONRecordNew = NATIONRecordIRs.NATIONRecordNew
  val NATIONRecordGetField = NATIONRecordIRs.NATIONRecordGetField
  type NATIONRecordGetField = NATIONRecordIRs.NATIONRecordGetField
  val NATIONRecord_Field_N_COMMENT = NATIONRecordIRs.NATIONRecord_Field_N_COMMENT
  type NATIONRecord_Field_N_COMMENT = NATIONRecordIRs.NATIONRecord_Field_N_COMMENT
  val NATIONRecord_Field_N_REGIONKEY = NATIONRecordIRs.NATIONRecord_Field_N_REGIONKEY
  type NATIONRecord_Field_N_REGIONKEY = NATIONRecordIRs.NATIONRecord_Field_N_REGIONKEY
  val NATIONRecord_Field_N_NAME = NATIONRecordIRs.NATIONRecord_Field_N_NAME
  type NATIONRecord_Field_N_NAME = NATIONRecordIRs.NATIONRecord_Field_N_NAME
  val NATIONRecord_Field_N_NATIONKEY = NATIONRecordIRs.NATIONRecord_Field_N_NATIONKEY
  type NATIONRecord_Field_N_NATIONKEY = NATIONRecordIRs.NATIONRecord_Field_N_NATIONKEY
  // method definitions
  def nATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = NATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  def nATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]): Rep[Option[Any]] = NATIONRecordGetField(self, key)
  def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_COMMENT(self)
  def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_REGIONKEY(self)
  def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_NAME(self)
  def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_NATIONKEY(self)
  def nATIONRecordApplyObject(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = {
    __newNATIONRecord(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  }
  type NATIONRecord = ch.epfl.data.dblab.experimentation.tpch.NATIONRecord
}
object NATIONRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object NATIONRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[NATIONRecord](scala.reflect.runtime.universe.typeOf[NATIONRecord]) {
    override def isRecord = true
  }
  implicit val typeNATIONRecord: TypeRep[NATIONRecord] = NATIONRecordType
  // case classes
  case class NATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]) extends ConstructorDef[NATIONRecord](List(), "NATIONRecord", List(List(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class NATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class NATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[NATIONRecord]
      self.N_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class NATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_REGIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[NATIONRecord]
      self.N_REGIONKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class NATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]) extends FieldDef[OptimalString](self, "N_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[NATIONRecord]
      self.N_NAME
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class NATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]) extends FieldDef[Int](self, "N_NATIONKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[NATIONRecord]
      self.N_NATIONKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type NATIONRecord = ch.epfl.data.dblab.experimentation.tpch.NATIONRecord
}
trait NATIONRecordImplicits extends NATIONRecordOps {
  // Add implicit conversions here!
}
trait NATIONRecordComponent extends NATIONRecordOps with NATIONRecordImplicits {}

trait NATIONRecordPartialEvaluation extends NATIONRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = self match {
    case Def(node: NATIONRecordNew) => node.N_COMMENT
    case _                          => super.nATIONRecord_Field_N_COMMENT(self)
  }
  override def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = self match {
    case Def(node: NATIONRecordNew) => node.N_REGIONKEY
    case _                          => super.nATIONRecord_Field_N_REGIONKEY(self)
  }
  override def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = self match {
    case Def(node: NATIONRecordNew) => node.N_NAME
    case _                          => super.nATIONRecord_Field_N_NAME(self)
  }
  override def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = self match {
    case Def(node: NATIONRecordNew) => node.N_NATIONKEY
    case _                          => super.nATIONRecord_Field_N_NATIONKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object NATIONRecordQuasiNodes extends BaseExtIR {
  import NATIONRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class NATIONRecordNewExt(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]) extends FunctionDef[NATIONRecordNew, NATIONRecord] {
    override def nodeUnapply(t: NATIONRecordNew): Option[Product] = (NATIONRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class NATIONRecordGetFieldExt(self: Rep[NATIONRecord], key: Rep[String]) extends FunctionDef[NATIONRecordGetField, Option[Any]] {
    override def nodeUnapply(t: NATIONRecordGetField): Option[Product] = (NATIONRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class NATIONRecord_Field_N_COMMENTExt(self: Rep[NATIONRecord]) extends FunctionDef[NATIONRecord_Field_N_COMMENT, OptimalString] {
    override def nodeUnapply(t: NATIONRecord_Field_N_COMMENT): Option[Product] = (NATIONRecord_Field_N_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class NATIONRecord_Field_N_REGIONKEYExt(self: Rep[NATIONRecord]) extends FunctionDef[NATIONRecord_Field_N_REGIONKEY, Int] {
    override def nodeUnapply(t: NATIONRecord_Field_N_REGIONKEY): Option[Product] = (NATIONRecord_Field_N_REGIONKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class NATIONRecord_Field_N_NAMEExt(self: Rep[NATIONRecord]) extends FunctionDef[NATIONRecord_Field_N_NAME, OptimalString] {
    override def nodeUnapply(t: NATIONRecord_Field_N_NAME): Option[Product] = (NATIONRecord_Field_N_NAME.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class NATIONRecord_Field_N_NATIONKEYExt(self: Rep[NATIONRecord]) extends FunctionDef[NATIONRecord_Field_N_NATIONKEY, Int] {
    override def nodeUnapply(t: NATIONRecord_Field_N_NATIONKEY): Option[Product] = (NATIONRecord_Field_N_NATIONKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type NATIONRecord = ch.epfl.data.dblab.experimentation.tpch.NATIONRecord
}

trait NATIONRecordExtOps extends BaseExt with OptimalStringExtOps {

  import NATIONRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class NATIONRecordRep(self: Rep[NATIONRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = nATIONRecordGetField(self, key)
    def N_COMMENT: Rep[OptimalString] = nATIONRecord_Field_N_COMMENT(self)
    def N_REGIONKEY: Rep[Int] = nATIONRecord_Field_N_REGIONKEY(self)
    def N_NAME: Rep[OptimalString] = nATIONRecord_Field_N_NAME(self)
    def N_NATIONKEY: Rep[Int] = nATIONRecord_Field_N_NATIONKEY(self)
  }
  object NATIONRecord {
    def apply(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordApplyObject(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  }
  // constructors
  def __newNATIONRecord(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = nATIONRecordNew(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)

  // method definitions
  def nATIONRecordApplyObject(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = { __newNATIONRecord(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT) }
  def nATIONRecordNew(N_NATIONKEY: Rep[Int], N_NAME: Rep[OptimalString], N_REGIONKEY: Rep[Int], N_COMMENT: Rep[OptimalString]): Rep[NATIONRecord] = NATIONRecordNewExt(N_NATIONKEY, N_NAME, N_REGIONKEY, N_COMMENT)
  def nATIONRecordGetField(self: Rep[NATIONRecord], key: Rep[String]): Rep[Option[Any]] = NATIONRecordGetFieldExt(self, key)
  def nATIONRecord_Field_N_COMMENT(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_COMMENTExt(self)
  def nATIONRecord_Field_N_REGIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_REGIONKEYExt(self)
  def nATIONRecord_Field_N_NAME(self: Rep[NATIONRecord]): Rep[OptimalString] = NATIONRecord_Field_N_NAMEExt(self)
  def nATIONRecord_Field_N_NATIONKEY(self: Rep[NATIONRecord]): Rep[Int] = NATIONRecord_Field_N_NATIONKEYExt(self)
  type NATIONRecord = ch.epfl.data.dblab.experimentation.tpch.NATIONRecord
}

trait PARTRecordOps extends Base with OptimalStringOps {
  // Type representation
  val PARTRecordType = PARTRecordIRs.PARTRecordType
  implicit val typePARTRecord: TypeRep[PARTRecord] = PARTRecordType
  implicit class PARTRecordRep(self: Rep[PARTRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTRecordGetField(self, key)
    def P_COMMENT: Rep[OptimalString] = pARTRecord_Field_P_COMMENT(self)
    def P_RETAILPRICE: Rep[Double] = pARTRecord_Field_P_RETAILPRICE(self)
    def P_CONTAINER: Rep[OptimalString] = pARTRecord_Field_P_CONTAINER(self)
    def P_SIZE: Rep[Int] = pARTRecord_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = pARTRecord_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = pARTRecord_Field_P_BRAND(self)
    def P_MFGR: Rep[OptimalString] = pARTRecord_Field_P_MFGR(self)
    def P_NAME: Rep[OptimalString] = pARTRecord_Field_P_NAME(self)
    def P_PARTKEY: Rep[Int] = pARTRecord_Field_P_PARTKEY(self)
  }
  object PARTRecord {
    def apply(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordApplyObject(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  }
  // constructors
  def __newPARTRecord(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  // IR defs
  val PARTRecordNew = PARTRecordIRs.PARTRecordNew
  type PARTRecordNew = PARTRecordIRs.PARTRecordNew
  val PARTRecordGetField = PARTRecordIRs.PARTRecordGetField
  type PARTRecordGetField = PARTRecordIRs.PARTRecordGetField
  val PARTRecord_Field_P_COMMENT = PARTRecordIRs.PARTRecord_Field_P_COMMENT
  type PARTRecord_Field_P_COMMENT = PARTRecordIRs.PARTRecord_Field_P_COMMENT
  val PARTRecord_Field_P_RETAILPRICE = PARTRecordIRs.PARTRecord_Field_P_RETAILPRICE
  type PARTRecord_Field_P_RETAILPRICE = PARTRecordIRs.PARTRecord_Field_P_RETAILPRICE
  val PARTRecord_Field_P_CONTAINER = PARTRecordIRs.PARTRecord_Field_P_CONTAINER
  type PARTRecord_Field_P_CONTAINER = PARTRecordIRs.PARTRecord_Field_P_CONTAINER
  val PARTRecord_Field_P_SIZE = PARTRecordIRs.PARTRecord_Field_P_SIZE
  type PARTRecord_Field_P_SIZE = PARTRecordIRs.PARTRecord_Field_P_SIZE
  val PARTRecord_Field_P_TYPE = PARTRecordIRs.PARTRecord_Field_P_TYPE
  type PARTRecord_Field_P_TYPE = PARTRecordIRs.PARTRecord_Field_P_TYPE
  val PARTRecord_Field_P_BRAND = PARTRecordIRs.PARTRecord_Field_P_BRAND
  type PARTRecord_Field_P_BRAND = PARTRecordIRs.PARTRecord_Field_P_BRAND
  val PARTRecord_Field_P_MFGR = PARTRecordIRs.PARTRecord_Field_P_MFGR
  type PARTRecord_Field_P_MFGR = PARTRecordIRs.PARTRecord_Field_P_MFGR
  val PARTRecord_Field_P_NAME = PARTRecordIRs.PARTRecord_Field_P_NAME
  type PARTRecord_Field_P_NAME = PARTRecordIRs.PARTRecord_Field_P_NAME
  val PARTRecord_Field_P_PARTKEY = PARTRecordIRs.PARTRecord_Field_P_PARTKEY
  type PARTRecord_Field_P_PARTKEY = PARTRecordIRs.PARTRecord_Field_P_PARTKEY
  // method definitions
  def pARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = PARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  def pARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]): Rep[Option[Any]] = PARTRecordGetField(self, key)
  def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_COMMENT(self)
  def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = PARTRecord_Field_P_RETAILPRICE(self)
  def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_CONTAINER(self)
  def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_SIZE(self)
  def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_TYPE(self)
  def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_BRAND(self)
  def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_MFGR(self)
  def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_NAME(self)
  def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_PARTKEY(self)
  def pARTRecordApplyObject(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = {
    __newPARTRecord(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  }
  type PARTRecord = ch.epfl.data.dblab.experimentation.tpch.PARTRecord
}
object PARTRecordIRs extends Base {
  import OptimalStringIRs._
  // Type representation
  case object PARTRecordType extends ch.epfl.data.sc.pardis.types.ReflectionType[PARTRecord](scala.reflect.runtime.universe.typeOf[PARTRecord]) {
    override def isRecord = true
  }
  implicit val typePARTRecord: TypeRep[PARTRecord] = PARTRecordType
  // case classes
  case class PARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]) extends ConstructorDef[PARTRecord](List(), "PARTRecord", List(List(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT))) {
    override def curriedConstructor = (copy _).curried
    override def isPure = true

  }

  case class PARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]) extends FunctionDef[Option[Any]](Some(self), "getField", List(List(key))) {
    override def curriedConstructor = (copy _).curried
  }

  case class PARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_COMMENT") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_COMMENT
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]) extends FieldDef[Double](self, "P_RETAILPRICE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Double = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_RETAILPRICE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_CONTAINER") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_CONTAINER
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_SIZE(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_SIZE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_SIZE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_TYPE(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_TYPE") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_TYPE
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_BRAND(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_BRAND") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_BRAND
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_MFGR(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_MFGR") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_MFGR
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_NAME(self: Rep[PARTRecord]) extends FieldDef[OptimalString](self, "P_NAME") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): OptimalString = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_NAME
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class PARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]) extends FieldDef[Int](self, "P_PARTKEY") {
    override def curriedConstructor = (copy _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Int = {
      val self = children(0).asInstanceOf[PARTRecord]
      self.P_PARTKEY
    }
    override def partiallyEvaluable: Boolean = true

  }

  type PARTRecord = ch.epfl.data.dblab.experimentation.tpch.PARTRecord
}
trait PARTRecordImplicits extends PARTRecordOps {
  // Add implicit conversions here!
}
trait PARTRecordComponent extends PARTRecordOps with PARTRecordImplicits {}

trait PARTRecordPartialEvaluation extends PARTRecordComponent with BasePartialEvaluation {
  // Immutable field inlining 
  override def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_COMMENT
    case _                        => super.pARTRecord_Field_P_COMMENT(self)
  }
  override def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = self match {
    case Def(node: PARTRecordNew) => node.P_RETAILPRICE
    case _                        => super.pARTRecord_Field_P_RETAILPRICE(self)
  }
  override def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_CONTAINER
    case _                        => super.pARTRecord_Field_P_CONTAINER(self)
  }
  override def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = self match {
    case Def(node: PARTRecordNew) => node.P_SIZE
    case _                        => super.pARTRecord_Field_P_SIZE(self)
  }
  override def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_TYPE
    case _                        => super.pARTRecord_Field_P_TYPE(self)
  }
  override def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_BRAND
    case _                        => super.pARTRecord_Field_P_BRAND(self)
  }
  override def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_MFGR
    case _                        => super.pARTRecord_Field_P_MFGR(self)
  }
  override def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = self match {
    case Def(node: PARTRecordNew) => node.P_NAME
    case _                        => super.pARTRecord_Field_P_NAME(self)
  }
  override def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = self match {
    case Def(node: PARTRecordNew) => node.P_PARTKEY
    case _                        => super.pARTRecord_Field_P_PARTKEY(self)
  }

  // Mutable field inlining 
  // Pure function partial evaluation
}

// QUASI GENERATED CODE:

object PARTRecordQuasiNodes extends BaseExtIR {
  import PARTRecordIRs._
  import OptimalStringQuasiNodes._
  // case classes
  case class PARTRecordNewExt(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]) extends FunctionDef[PARTRecordNew, PARTRecord] {
    override def nodeUnapply(t: PARTRecordNew): Option[Product] = (PARTRecordNew.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecordGetFieldExt(self: Rep[PARTRecord], key: Rep[String]) extends FunctionDef[PARTRecordGetField, Option[Any]] {
    override def nodeUnapply(t: PARTRecordGetField): Option[Product] = (PARTRecordGetField.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_COMMENTExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_COMMENT, OptimalString] {
    override def nodeUnapply(t: PARTRecord_Field_P_COMMENT): Option[Product] = (PARTRecord_Field_P_COMMENT.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_RETAILPRICEExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_RETAILPRICE, Double] {
    override def nodeUnapply(t: PARTRecord_Field_P_RETAILPRICE): Option[Product] = (PARTRecord_Field_P_RETAILPRICE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_CONTAINERExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_CONTAINER, OptimalString] {
    override def nodeUnapply(t: PARTRecord_Field_P_CONTAINER): Option[Product] = (PARTRecord_Field_P_CONTAINER.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_SIZEExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_SIZE, Int] {
    override def nodeUnapply(t: PARTRecord_Field_P_SIZE): Option[Product] = (PARTRecord_Field_P_SIZE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_TYPEExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_TYPE, OptimalString] {
    override def nodeUnapply(t: PARTRecord_Field_P_TYPE): Option[Product] = (PARTRecord_Field_P_TYPE.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_BRANDExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_BRAND, OptimalString] {
    override def nodeUnapply(t: PARTRecord_Field_P_BRAND): Option[Product] = (PARTRecord_Field_P_BRAND.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_MFGRExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_MFGR, OptimalString] {
    override def nodeUnapply(t: PARTRecord_Field_P_MFGR): Option[Product] = (PARTRecord_Field_P_MFGR.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_NAMEExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_NAME, OptimalString] {
    override def nodeUnapply(t: PARTRecord_Field_P_NAME): Option[Product] = (PARTRecord_Field_P_NAME.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  case class PARTRecord_Field_P_PARTKEYExt(self: Rep[PARTRecord]) extends FunctionDef[PARTRecord_Field_P_PARTKEY, Int] {
    override def nodeUnapply(t: PARTRecord_Field_P_PARTKEY): Option[Product] = (PARTRecord_Field_P_PARTKEY.unapply(t): Option[Product]) map { r =>
      r
    }
  }
  type PARTRecord = ch.epfl.data.dblab.experimentation.tpch.PARTRecord
}

trait PARTRecordExtOps extends BaseExt with OptimalStringExtOps {

  import PARTRecordQuasiNodes._
  import ch.epfl.data.sc.pardis.quasi.OverloadHackObj._
  import OptimalStringQuasiNodes._
  implicit class PARTRecordRep(self: Rep[PARTRecord]) {
    def getField(key: Rep[String]): Rep[Option[Any]] = pARTRecordGetField(self, key)
    def P_COMMENT: Rep[OptimalString] = pARTRecord_Field_P_COMMENT(self)
    def P_RETAILPRICE: Rep[Double] = pARTRecord_Field_P_RETAILPRICE(self)
    def P_CONTAINER: Rep[OptimalString] = pARTRecord_Field_P_CONTAINER(self)
    def P_SIZE: Rep[Int] = pARTRecord_Field_P_SIZE(self)
    def P_TYPE: Rep[OptimalString] = pARTRecord_Field_P_TYPE(self)
    def P_BRAND: Rep[OptimalString] = pARTRecord_Field_P_BRAND(self)
    def P_MFGR: Rep[OptimalString] = pARTRecord_Field_P_MFGR(self)
    def P_NAME: Rep[OptimalString] = pARTRecord_Field_P_NAME(self)
    def P_PARTKEY: Rep[Int] = pARTRecord_Field_P_PARTKEY(self)
  }
  object PARTRecord {
    def apply(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordApplyObject(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  }
  // constructors
  def __newPARTRecord(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = pARTRecordNew(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)

  // method definitions
  def pARTRecordApplyObject(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = { __newPARTRecord(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT) }
  def pARTRecordNew(P_PARTKEY: Rep[Int], P_NAME: Rep[OptimalString], P_MFGR: Rep[OptimalString], P_BRAND: Rep[OptimalString], P_TYPE: Rep[OptimalString], P_SIZE: Rep[Int], P_CONTAINER: Rep[OptimalString], P_RETAILPRICE: Rep[Double], P_COMMENT: Rep[OptimalString]): Rep[PARTRecord] = PARTRecordNewExt(P_PARTKEY, P_NAME, P_MFGR, P_BRAND, P_TYPE, P_SIZE, P_CONTAINER, P_RETAILPRICE, P_COMMENT)
  def pARTRecordGetField(self: Rep[PARTRecord], key: Rep[String]): Rep[Option[Any]] = PARTRecordGetFieldExt(self, key)
  def pARTRecord_Field_P_COMMENT(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_COMMENTExt(self)
  def pARTRecord_Field_P_RETAILPRICE(self: Rep[PARTRecord]): Rep[Double] = PARTRecord_Field_P_RETAILPRICEExt(self)
  def pARTRecord_Field_P_CONTAINER(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_CONTAINERExt(self)
  def pARTRecord_Field_P_SIZE(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_SIZEExt(self)
  def pARTRecord_Field_P_TYPE(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_TYPEExt(self)
  def pARTRecord_Field_P_BRAND(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_BRANDExt(self)
  def pARTRecord_Field_P_MFGR(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_MFGRExt(self)
  def pARTRecord_Field_P_NAME(self: Rep[PARTRecord]): Rep[OptimalString] = PARTRecord_Field_P_NAMEExt(self)
  def pARTRecord_Field_P_PARTKEY(self: Rep[PARTRecord]): Rep[Int] = PARTRecord_Field_P_PARTKEYExt(self)
  type PARTRecord = ch.epfl.data.dblab.experimentation.tpch.PARTRecord
}

