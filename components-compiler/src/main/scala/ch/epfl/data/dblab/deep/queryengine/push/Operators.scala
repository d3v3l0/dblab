/* Generated by Purgatory 2014-2017 */

package ch.epfl.data.dblab.deep.queryengine.push
import ch.epfl.data.dblab.deep._
import ch.epfl.data.dblab.deep.common._
import ch.epfl.data.dblab.deep.queryengine._
import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

import ch.epfl.data.sc.pardis.quasi.anf.{ BaseExt, BaseExtIR }
import ch.epfl.data.sc.pardis.quasi.TypeParameters.MaybeParamTag

trait OperatorOps extends Base with ScalaCoreOps { this: OperatorsComponent =>
  // Type representation
  val OperatorType = OperatorIRs.OperatorType
  type OperatorType[A] = OperatorIRs.OperatorType[A]
  implicit def typeOperator[A: TypeRep]: TypeRep[Operator[A]] = OperatorType(implicitly[TypeRep[A]])
  implicit class OperatorRep[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]) {
    def open(): Rep[Unit] = operatorOpen[A](self)(typeA)
    def init(): Rep[Unit] = operatorInit[A](self)(typeA)
    def reset(): Rep[Unit] = operatorReset[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = operatorConsume[A](self, tuple)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = operator_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = operator_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = operator_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = operator_Field_Child[A](self)(typeA)
  }
  object Operator {

  }
  // constructors

  // IR defs
  val OperatorOpen = OperatorIRs.OperatorOpen
  type OperatorOpen[A] = OperatorIRs.OperatorOpen[A]
  val OperatorInit = OperatorIRs.OperatorInit
  type OperatorInit[A] = OperatorIRs.OperatorInit[A]
  val OperatorReset = OperatorIRs.OperatorReset
  type OperatorReset[A] = OperatorIRs.OperatorReset[A]
  val OperatorConsume = OperatorIRs.OperatorConsume
  type OperatorConsume[A] = OperatorIRs.OperatorConsume[A]
  val Operator_Field_Stop__eq = OperatorIRs.Operator_Field_Stop__eq
  type Operator_Field_Stop__eq[A] = OperatorIRs.Operator_Field_Stop__eq[A]
  val Operator_Field_Stop = OperatorIRs.Operator_Field_Stop
  type Operator_Field_Stop[A] = OperatorIRs.Operator_Field_Stop[A]
  val Operator_Field_Child__eq = OperatorIRs.Operator_Field_Child__eq
  type Operator_Field_Child__eq[A] = OperatorIRs.Operator_Field_Child__eq[A]
  val Operator_Field_Child = OperatorIRs.Operator_Field_Child
  type Operator_Field_Child[A] = OperatorIRs.Operator_Field_Child[A]
  // method definitions
  def operatorOpen[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = OperatorOpen[A](self)
  def operatorInit[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = OperatorInit[A](self)
  def operatorReset[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = OperatorReset[A](self)
  def operatorConsume[A](self: Rep[Operator[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = OperatorConsume[A](self, tuple)
  def operator_Field_Stop_$eq[A](self: Rep[Operator[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = Operator_Field_Stop__eq[A](self, x$1)
  def operator_Field_Stop[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = Operator_Field_Stop[A](self)
  def operator_Field_Child_$eq[A](self: Rep[Operator[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = Operator_Field_Child__eq[A](self, x$1)
  def operator_Field_Child[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = Operator_Field_Child[A](self)
  type Operator[A] = ch.epfl.data.dblab.queryengine.push.Operator[A]
}
object OperatorIRs extends Base {
  import ScalaCoreIRs._
  // Type representation
  case class OperatorType[A](typeA: TypeRep[A]) extends TypeRep[Operator[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = OperatorType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"Operator[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeOperator[A: TypeRep]: TypeRep[Operator[A]] = OperatorType(implicitly[TypeRep[A]])
  // case classes
  case class OperatorOpen[A](self: Rep[Operator[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class OperatorInit[A](self: Rep[Operator[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class OperatorReset[A](self: Rep[Operator[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class OperatorConsume[A](self: Rep[Operator[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class Operator_Field_Stop__eq[A](self: Rep[Operator[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class Operator_Field_Stop[A](self: Rep[Operator[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class Operator_Field_Child__eq[A](self: Rep[Operator[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class Operator_Field_Child[A](self: Rep[Operator[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type Operator[A] = ch.epfl.data.dblab.queryengine.push.Operator[A]
}
trait OperatorImplicits extends OperatorOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait OperatorComponent extends OperatorOps with OperatorImplicits { this: OperatorsComponent => }

trait OperatorImplementations extends OperatorOps { this: OperatorsComponent =>

}

trait OperatorPartialEvaluation extends OperatorComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 

  // Mutable field inlining 
  override def operator_Field_Child_$eq[A](self: Rep[Operator[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def operator_Field_Child[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait ScanOpOps extends Base with ExceptionOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val ScanOpType = ScanOpIRs.ScanOpType
  type ScanOpType[A] = ScanOpIRs.ScanOpType[A]
  implicit def typeScanOp[A: TypeRep]: TypeRep[ScanOp[A]] = ScanOpType(implicitly[TypeRep[A]])
  implicit class ScanOpRep[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]) {
    def open(): Rep[Unit] = scanOpOpen[A](self)(typeA)
    def init(): Rep[Unit] = scanOpInit[A](self)(typeA)
    def reset(): Rep[Unit] = scanOpReset[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = scanOpConsume[A](self, tuple)(typeA)
    def i_=(x$1: Rep[Int]): Rep[Unit] = scanOp_Field_I_$eq[A](self, x$1)(typeA)
    def i: Rep[Int] = scanOp_Field_I[A](self)(typeA)
    def table: Rep[Array[A]] = scanOp_Field_Table[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = scanOp_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = scanOp_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = scanOp_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = scanOp_Field_Child[A](self)(typeA)
  }
  object ScanOp {

  }
  // constructors
  def __newScanOp[A](table: Rep[Array[A]])(implicit typeA: TypeRep[A]): Rep[ScanOp[A]] = scanOpNew[A](table)(typeA)
  // IR defs
  val ScanOpNew = ScanOpIRs.ScanOpNew
  type ScanOpNew[A] = ScanOpIRs.ScanOpNew[A]
  val ScanOpOpen = ScanOpIRs.ScanOpOpen
  type ScanOpOpen[A] = ScanOpIRs.ScanOpOpen[A]
  val ScanOpInit = ScanOpIRs.ScanOpInit
  type ScanOpInit[A] = ScanOpIRs.ScanOpInit[A]
  val ScanOpReset = ScanOpIRs.ScanOpReset
  type ScanOpReset[A] = ScanOpIRs.ScanOpReset[A]
  val ScanOpConsume = ScanOpIRs.ScanOpConsume
  type ScanOpConsume[A] = ScanOpIRs.ScanOpConsume[A]
  val ScanOp_Field_I__eq = ScanOpIRs.ScanOp_Field_I__eq
  type ScanOp_Field_I__eq[A] = ScanOpIRs.ScanOp_Field_I__eq[A]
  val ScanOp_Field_I = ScanOpIRs.ScanOp_Field_I
  type ScanOp_Field_I[A] = ScanOpIRs.ScanOp_Field_I[A]
  val ScanOp_Field_Table = ScanOpIRs.ScanOp_Field_Table
  type ScanOp_Field_Table[A] = ScanOpIRs.ScanOp_Field_Table[A]
  val ScanOp_Field_Stop__eq = ScanOpIRs.ScanOp_Field_Stop__eq
  type ScanOp_Field_Stop__eq[A] = ScanOpIRs.ScanOp_Field_Stop__eq[A]
  val ScanOp_Field_Stop = ScanOpIRs.ScanOp_Field_Stop
  type ScanOp_Field_Stop[A] = ScanOpIRs.ScanOp_Field_Stop[A]
  val ScanOp_Field_Child__eq = ScanOpIRs.ScanOp_Field_Child__eq
  type ScanOp_Field_Child__eq[A] = ScanOpIRs.ScanOp_Field_Child__eq[A]
  val ScanOp_Field_Child = ScanOpIRs.ScanOp_Field_Child
  type ScanOp_Field_Child[A] = ScanOpIRs.ScanOp_Field_Child[A]
  // method definitions
  def scanOpNew[A](table: Rep[Array[A]])(implicit typeA: TypeRep[A]): Rep[ScanOp[A]] = ScanOpNew[A](table)
  def scanOpOpen[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOpOpen[A](self)
  def scanOpInit[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOpInit[A](self)
  def scanOpReset[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOpReset[A](self)
  def scanOpConsume[A](self: Rep[ScanOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOpConsume[A](self, tuple)
  def scanOp_Field_I_$eq[A](self: Rep[ScanOp[A]], x$1: Rep[Int])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOp_Field_I__eq[A](self, x$1)
  def scanOp_Field_I[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Int] = ScanOp_Field_I[A](self)
  def scanOp_Field_Table[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Array[A]] = ScanOp_Field_Table[A](self)
  def scanOp_Field_Stop_$eq[A](self: Rep[ScanOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOp_Field_Stop__eq[A](self, x$1)
  def scanOp_Field_Stop[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = ScanOp_Field_Stop[A](self)
  def scanOp_Field_Child_$eq[A](self: Rep[ScanOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = ScanOp_Field_Child__eq[A](self, x$1)
  def scanOp_Field_Child[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = ScanOp_Field_Child[A](self)
  type ScanOp[A] = ch.epfl.data.dblab.queryengine.push.ScanOp[A]
}
object ScanOpIRs extends Base {
  import ExceptionIRs._
  import OperatorIRs._
  // Type representation
  case class ScanOpType[A](typeA: TypeRep[A]) extends TypeRep[ScanOp[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ScanOpType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"ScanOp[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeScanOp[A: TypeRep]: TypeRep[ScanOp[A]] = ScanOpType(implicitly[TypeRep[A]])
  // case classes
  case class ScanOpNew[A](table: Rep[Array[A]])(implicit val typeA: TypeRep[A]) extends ConstructorDef[ScanOp[A]](List(typeA), "ScanOp", List(List(table))) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ScanOpOpen[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ScanOpInit[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ScanOpReset[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ScanOpConsume[A](self: Rep[ScanOp[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ScanOp_Field_I__eq[A](self: Rep[ScanOp[A]], x$1: Rep[Int])(implicit val typeA: TypeRep[A]) extends FieldSetter[Int](self, "i", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ScanOp_Field_I[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Int](self, "i") {
    override def curriedConstructor = (copy[A] _)
  }

  case class ScanOp_Field_Table[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Array[A]](self, "table") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class ScanOp_Field_Stop__eq[A](self: Rep[ScanOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ScanOp_Field_Stop[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class ScanOp_Field_Child__eq[A](self: Rep[ScanOp[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ScanOp_Field_Child[A](self: Rep[ScanOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type ScanOp[A] = ch.epfl.data.dblab.queryengine.push.ScanOp[A]
}
trait ScanOpImplicits extends ScanOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait ScanOpComponent extends ScanOpOps with ScanOpImplicits { this: OperatorsComponent => }

trait ScanOpImplementations extends ScanOpOps { this: OperatorsComponent =>
  override def scanOpOpen[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    unit(())
  }
  override def scanOpInit[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    __whileDo(self.stop.unary_$bang.$amp$amp(self.i.$less(self.table.length)), {
      self.child.consume(infix_asInstanceOf[ch.epfl.data.sc.pardis.shallow.Record](self.table.apply(self.i)));
      self.i_$eq(self.i.$plus(unit(1)))
    })
  }
  override def scanOpReset[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.i_$eq(unit(0))
  }
  override def scanOpConsume[A](self: Rep[ScanOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    throw __newException(unit("PUSH ENGINE BUG:: Consume function in ScanOp should never be called!!!!\n"))
  }
}

trait ScanOpPartialEvaluation extends ScanOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def scanOp_Field_Table[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Array[A]] = self match {
    case Def(node: ScanOpNew[_]) => node.table
    case _                       => super.scanOp_Field_Table[A](self)(typeA)
  }

  // Mutable field inlining 
  override def scanOp_Field_Child_$eq[A](self: Rep[ScanOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def scanOp_Field_Child[A](self: Rep[ScanOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait PrintOpOps extends Base with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val PrintOpType = PrintOpIRs.PrintOpType
  type PrintOpType[A] = PrintOpIRs.PrintOpType[A]
  implicit def typePrintOp[A: TypeRep]: TypeRep[PrintOp[A]] = PrintOpType(implicitly[TypeRep[A]])
  implicit class PrintOpRep[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]) {
    def open(): Rep[Unit] = printOpOpen[A](self)(typeA)
    def init(): Rep[Unit] = printOpInit[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = printOpConsume[A](self, tuple)(typeA)
    def run(): Rep[Unit] = printOpRun[A](self)(typeA)
    def reset(): Rep[Unit] = printOpReset[A](self)(typeA)
    def numRows_=(x$1: Rep[Int]): Rep[Unit] = printOp_Field_NumRows_$eq[A](self, x$1)(typeA)
    def numRows: Rep[Int] = printOp_Field_NumRows[A](self)(typeA)
    def limit: Rep[Int] = printOp_Field_Limit[A](self)(typeA)
    def printFunc: Rep[(A => Unit)] = printOp_Field_PrintFunc[A](self)(typeA)
    def parent: Rep[Operator[A]] = printOp_Field_Parent[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = printOp_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = printOp_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = printOp_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = printOp_Field_Child[A](self)(typeA)
  }
  object PrintOp {

  }
  // constructors
  def __newPrintOp[A](parent: Rep[Operator[A]])(printFunc: Rep[(A => Unit)], limit: Rep[Int])(implicit typeA: TypeRep[A]): Rep[PrintOp[A]] = printOpNew[A](parent, printFunc, limit)(typeA)
  // IR defs
  val PrintOpNew = PrintOpIRs.PrintOpNew
  type PrintOpNew[A] = PrintOpIRs.PrintOpNew[A]
  val PrintOpOpen = PrintOpIRs.PrintOpOpen
  type PrintOpOpen[A] = PrintOpIRs.PrintOpOpen[A]
  val PrintOpInit = PrintOpIRs.PrintOpInit
  type PrintOpInit[A] = PrintOpIRs.PrintOpInit[A]
  val PrintOpConsume = PrintOpIRs.PrintOpConsume
  type PrintOpConsume[A] = PrintOpIRs.PrintOpConsume[A]
  val PrintOpRun = PrintOpIRs.PrintOpRun
  type PrintOpRun[A] = PrintOpIRs.PrintOpRun[A]
  val PrintOpReset = PrintOpIRs.PrintOpReset
  type PrintOpReset[A] = PrintOpIRs.PrintOpReset[A]
  val PrintOp_Field_NumRows__eq = PrintOpIRs.PrintOp_Field_NumRows__eq
  type PrintOp_Field_NumRows__eq[A] = PrintOpIRs.PrintOp_Field_NumRows__eq[A]
  val PrintOp_Field_NumRows = PrintOpIRs.PrintOp_Field_NumRows
  type PrintOp_Field_NumRows[A] = PrintOpIRs.PrintOp_Field_NumRows[A]
  val PrintOp_Field_Limit = PrintOpIRs.PrintOp_Field_Limit
  type PrintOp_Field_Limit[A] = PrintOpIRs.PrintOp_Field_Limit[A]
  val PrintOp_Field_PrintFunc = PrintOpIRs.PrintOp_Field_PrintFunc
  type PrintOp_Field_PrintFunc[A] = PrintOpIRs.PrintOp_Field_PrintFunc[A]
  val PrintOp_Field_Parent = PrintOpIRs.PrintOp_Field_Parent
  type PrintOp_Field_Parent[A] = PrintOpIRs.PrintOp_Field_Parent[A]
  val PrintOp_Field_Stop__eq = PrintOpIRs.PrintOp_Field_Stop__eq
  type PrintOp_Field_Stop__eq[A] = PrintOpIRs.PrintOp_Field_Stop__eq[A]
  val PrintOp_Field_Stop = PrintOpIRs.PrintOp_Field_Stop
  type PrintOp_Field_Stop[A] = PrintOpIRs.PrintOp_Field_Stop[A]
  val PrintOp_Field_Child__eq = PrintOpIRs.PrintOp_Field_Child__eq
  type PrintOp_Field_Child__eq[A] = PrintOpIRs.PrintOp_Field_Child__eq[A]
  val PrintOp_Field_Child = PrintOpIRs.PrintOp_Field_Child
  type PrintOp_Field_Child[A] = PrintOpIRs.PrintOp_Field_Child[A]
  // method definitions
  def printOpNew[A](parent: Rep[Operator[A]], printFunc: Rep[((A) => Unit)], limit: Rep[Int])(implicit typeA: TypeRep[A]): Rep[PrintOp[A]] = PrintOpNew[A](parent, printFunc, limit)
  def printOpOpen[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOpOpen[A](self)
  def printOpInit[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOpInit[A](self)
  def printOpConsume[A](self: Rep[PrintOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOpConsume[A](self, tuple)
  def printOpRun[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOpRun[A](self)
  def printOpReset[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOpReset[A](self)
  def printOp_Field_NumRows_$eq[A](self: Rep[PrintOp[A]], x$1: Rep[Int])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOp_Field_NumRows__eq[A](self, x$1)
  def printOp_Field_NumRows[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Int] = PrintOp_Field_NumRows[A](self)
  def printOp_Field_Limit[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Int] = PrintOp_Field_Limit[A](self)
  def printOp_Field_PrintFunc[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[(A => Unit)] = PrintOp_Field_PrintFunc[A](self)
  def printOp_Field_Parent[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = PrintOp_Field_Parent[A](self)
  def printOp_Field_Stop_$eq[A](self: Rep[PrintOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOp_Field_Stop__eq[A](self, x$1)
  def printOp_Field_Stop[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = PrintOp_Field_Stop[A](self)
  def printOp_Field_Child_$eq[A](self: Rep[PrintOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = PrintOp_Field_Child__eq[A](self, x$1)
  def printOp_Field_Child[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = PrintOp_Field_Child[A](self)
  type PrintOp[A] = ch.epfl.data.dblab.queryengine.push.PrintOp[A]
}
object PrintOpIRs extends Base {
  import OperatorIRs._
  // Type representation
  case class PrintOpType[A](typeA: TypeRep[A]) extends TypeRep[PrintOp[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = PrintOpType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"PrintOp[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typePrintOp[A: TypeRep]: TypeRep[PrintOp[A]] = PrintOpType(implicitly[TypeRep[A]])
  // case classes
  case class PrintOpNew[A](parent: Rep[Operator[A]], printFunc: Rep[((A) => Unit)], limit: Rep[Int])(implicit val typeA: TypeRep[A]) extends ConstructorDef[PrintOp[A]](List(typeA), "PrintOp", List(List(parent), List(printFunc, limit))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class PrintOpOpen[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class PrintOpInit[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class PrintOpConsume[A](self: Rep[PrintOp[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class PrintOpRun[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "run", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class PrintOpReset[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class PrintOp_Field_NumRows__eq[A](self: Rep[PrintOp[A]], x$1: Rep[Int])(implicit val typeA: TypeRep[A]) extends FieldSetter[Int](self, "numRows", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class PrintOp_Field_NumRows[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Int](self, "numRows") {
    override def curriedConstructor = (copy[A] _)
  }

  case class PrintOp_Field_Limit[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Int](self, "limit") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class PrintOp_Field_PrintFunc[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[(A => Unit)](self, "printFunc") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class PrintOp_Field_Parent[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class PrintOp_Field_Stop__eq[A](self: Rep[PrintOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class PrintOp_Field_Stop[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class PrintOp_Field_Child__eq[A](self: Rep[PrintOp[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class PrintOp_Field_Child[A](self: Rep[PrintOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type PrintOp[A] = ch.epfl.data.dblab.queryengine.push.PrintOp[A]
}
trait PrintOpImplicits extends PrintOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait PrintOpComponent extends PrintOpOps with PrintOpImplicits { this: OperatorsComponent => }

trait PrintOpImplementations extends PrintOpOps { this: OperatorsComponent =>
  override def printOpOpen[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def printOpInit[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.init();
      printf(unit("(%d rows)\n"), self.numRows)
    }
  }
  override def printOpConsume[A](self: Rep[PrintOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    __ifThenElse(infix_$bang$eq(self.limit, unit(-1)).$amp$amp(self.numRows.$greater$eq(self.limit)), self.parent.stop_$eq(unit(true)), {
      __app[A, Unit](self.printFunc).apply(infix_asInstanceOf[A](tuple));
      self.numRows_$eq(self.numRows.$plus(unit(1)))
    })
  }
  override def printOpRun[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.open();
      self.init()
    }
  }
  override def printOpReset[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.parent.reset()
  }
}

trait PrintOpPartialEvaluation extends PrintOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def printOp_Field_Limit[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Int] = self match {
    case Def(node: PrintOpNew[_]) => node.limit
    case _                        => super.printOp_Field_Limit[A](self)(typeA)
  }
  override def printOp_Field_PrintFunc[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[(A => Unit)] = self match {
    case Def(node: PrintOpNew[_]) => node.printFunc
    case _                        => super.printOp_Field_PrintFunc[A](self)(typeA)
  }
  override def printOp_Field_Parent[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = self match {
    case Def(node: PrintOpNew[_]) => node.parent
    case _                        => super.printOp_Field_Parent[A](self)(typeA)
  }

  // Mutable field inlining 
  override def printOp_Field_Child_$eq[A](self: Rep[PrintOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def printOp_Field_Child[A](self: Rep[PrintOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait SelectOpOps extends Base with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val SelectOpType = SelectOpIRs.SelectOpType
  type SelectOpType[A] = SelectOpIRs.SelectOpType[A]
  implicit def typeSelectOp[A: TypeRep]: TypeRep[SelectOp[A]] = SelectOpType(implicitly[TypeRep[A]])
  implicit class SelectOpRep[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]) {
    def open(): Rep[Unit] = selectOpOpen[A](self)(typeA)
    def init(): Rep[Unit] = selectOpInit[A](self)(typeA)
    def reset(): Rep[Unit] = selectOpReset[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = selectOpConsume[A](self, tuple)(typeA)
    def selectPred: Rep[(A => Boolean)] = selectOp_Field_SelectPred[A](self)(typeA)
    def parent: Rep[Operator[A]] = selectOp_Field_Parent[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = selectOp_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = selectOp_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = selectOp_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = selectOp_Field_Child[A](self)(typeA)
  }
  object SelectOp {

  }
  // constructors
  def __newSelectOp[A](parent: Rep[Operator[A]])(selectPred: Rep[(A => Boolean)])(implicit typeA: TypeRep[A]): Rep[SelectOp[A]] = selectOpNew[A](parent, selectPred)(typeA)
  // IR defs
  val SelectOpNew = SelectOpIRs.SelectOpNew
  type SelectOpNew[A] = SelectOpIRs.SelectOpNew[A]
  val SelectOpOpen = SelectOpIRs.SelectOpOpen
  type SelectOpOpen[A] = SelectOpIRs.SelectOpOpen[A]
  val SelectOpInit = SelectOpIRs.SelectOpInit
  type SelectOpInit[A] = SelectOpIRs.SelectOpInit[A]
  val SelectOpReset = SelectOpIRs.SelectOpReset
  type SelectOpReset[A] = SelectOpIRs.SelectOpReset[A]
  val SelectOpConsume = SelectOpIRs.SelectOpConsume
  type SelectOpConsume[A] = SelectOpIRs.SelectOpConsume[A]
  val SelectOp_Field_SelectPred = SelectOpIRs.SelectOp_Field_SelectPred
  type SelectOp_Field_SelectPred[A] = SelectOpIRs.SelectOp_Field_SelectPred[A]
  val SelectOp_Field_Parent = SelectOpIRs.SelectOp_Field_Parent
  type SelectOp_Field_Parent[A] = SelectOpIRs.SelectOp_Field_Parent[A]
  val SelectOp_Field_Stop__eq = SelectOpIRs.SelectOp_Field_Stop__eq
  type SelectOp_Field_Stop__eq[A] = SelectOpIRs.SelectOp_Field_Stop__eq[A]
  val SelectOp_Field_Stop = SelectOpIRs.SelectOp_Field_Stop
  type SelectOp_Field_Stop[A] = SelectOpIRs.SelectOp_Field_Stop[A]
  val SelectOp_Field_Child__eq = SelectOpIRs.SelectOp_Field_Child__eq
  type SelectOp_Field_Child__eq[A] = SelectOpIRs.SelectOp_Field_Child__eq[A]
  val SelectOp_Field_Child = SelectOpIRs.SelectOp_Field_Child
  type SelectOp_Field_Child[A] = SelectOpIRs.SelectOp_Field_Child[A]
  // method definitions
  def selectOpNew[A](parent: Rep[Operator[A]], selectPred: Rep[((A) => Boolean)])(implicit typeA: TypeRep[A]): Rep[SelectOp[A]] = SelectOpNew[A](parent, selectPred)
  def selectOpOpen[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SelectOpOpen[A](self)
  def selectOpInit[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SelectOpInit[A](self)
  def selectOpReset[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SelectOpReset[A](self)
  def selectOpConsume[A](self: Rep[SelectOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = SelectOpConsume[A](self, tuple)
  def selectOp_Field_SelectPred[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[(A => Boolean)] = SelectOp_Field_SelectPred[A](self)
  def selectOp_Field_Parent[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = SelectOp_Field_Parent[A](self)
  def selectOp_Field_Stop_$eq[A](self: Rep[SelectOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = SelectOp_Field_Stop__eq[A](self, x$1)
  def selectOp_Field_Stop[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = SelectOp_Field_Stop[A](self)
  def selectOp_Field_Child_$eq[A](self: Rep[SelectOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = SelectOp_Field_Child__eq[A](self, x$1)
  def selectOp_Field_Child[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = SelectOp_Field_Child[A](self)
  type SelectOp[A] = ch.epfl.data.dblab.queryengine.push.SelectOp[A]
}
object SelectOpIRs extends Base {
  import OperatorIRs._
  // Type representation
  case class SelectOpType[A](typeA: TypeRep[A]) extends TypeRep[SelectOp[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = SelectOpType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"SelectOp[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeSelectOp[A: TypeRep]: TypeRep[SelectOp[A]] = SelectOpType(implicitly[TypeRep[A]])
  // case classes
  case class SelectOpNew[A](parent: Rep[Operator[A]], selectPred: Rep[((A) => Boolean)])(implicit val typeA: TypeRep[A]) extends ConstructorDef[SelectOp[A]](List(typeA), "SelectOp", List(List(parent), List(selectPred))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SelectOpOpen[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SelectOpInit[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SelectOpReset[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SelectOpConsume[A](self: Rep[SelectOp[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SelectOp_Field_SelectPred[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[(A => Boolean)](self, "selectPred") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class SelectOp_Field_Parent[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class SelectOp_Field_Stop__eq[A](self: Rep[SelectOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SelectOp_Field_Stop[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class SelectOp_Field_Child__eq[A](self: Rep[SelectOp[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SelectOp_Field_Child[A](self: Rep[SelectOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type SelectOp[A] = ch.epfl.data.dblab.queryengine.push.SelectOp[A]
}
trait SelectOpImplicits extends SelectOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait SelectOpComponent extends SelectOpOps with SelectOpImplicits { this: OperatorsComponent => }

trait SelectOpImplementations extends SelectOpOps { this: OperatorsComponent =>
  override def selectOpOpen[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def selectOpInit[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.parent.init()
  }
  override def selectOpReset[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.parent.reset()
  }
  override def selectOpConsume[A](self: Rep[SelectOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    __ifThenElse(__app[A, Boolean](self.selectPred).apply(infix_asInstanceOf[A](tuple)), self.child.consume(tuple), unit(()))
  }
}

trait SelectOpPartialEvaluation extends SelectOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def selectOp_Field_SelectPred[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[(A => Boolean)] = self match {
    case Def(node: SelectOpNew[_]) => node.selectPred
    case _                         => super.selectOp_Field_SelectPred[A](self)(typeA)
  }
  override def selectOp_Field_Parent[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = self match {
    case Def(node: SelectOpNew[_]) => node.parent
    case _                         => super.selectOp_Field_Parent[A](self)(typeA)
  }

  // Mutable field inlining 
  override def selectOp_Field_Child_$eq[A](self: Rep[SelectOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def selectOp_Field_Child[A](self: Rep[SelectOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait AggOpOps extends Base with HashMapOps with AGGRecordOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val AggOpType = AggOpIRs.AggOpType
  type AggOpType[A, B] = AggOpIRs.AggOpType[A, B]
  implicit def typeAggOp[A: TypeRep, B: TypeRep]: TypeRep[AggOp[A, B]] = AggOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  implicit class AggOpRep[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]) {
    def open(): Rep[Unit] = aggOpOpen[A, B](self)(typeA, typeB)
    def init(): Rep[Unit] = aggOpInit[A, B](self)(typeA, typeB)
    def reset(): Rep[Unit] = aggOpReset[A, B](self)(typeA, typeB)
    def consume(tuple: Rep[Record]): Rep[Unit] = aggOpConsume[A, B](self, tuple)(typeA, typeB)
    def hm: Rep[HashMap[B, AGGRecord[B]]] = aggOp_Field_Hm[A, B](self)(typeA, typeB)
    def aggFuncs: Rep[Seq[((A, Double) => Double)]] = aggOp_Field_AggFuncs[A, B](self)(typeA, typeB)
    def grp: Rep[(A => B)] = aggOp_Field_Grp[A, B](self)(typeA, typeB)
    def numAggs: Rep[Int] = aggOp_Field_NumAggs[A, B](self)(typeA, typeB)
    def parent: Rep[Operator[A]] = aggOp_Field_Parent[A, B](self)(typeA, typeB)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = aggOp_Field_Stop_$eq[A, B](self, x$1)(typeA, typeB)
    def stop: Rep[Boolean] = aggOp_Field_Stop[A, B](self)(typeA, typeB)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = aggOp_Field_Child_$eq[A, B](self, x$1)(typeA, typeB)
    def child: Rep[Operator[Any]] = aggOp_Field_Child[A, B](self)(typeA, typeB)
  }
  object AggOp {

  }
  // constructors
  def __newAggOp[A, B](parent: Rep[Operator[A]], numAggs: Rep[Int])(grp: Rep[(A => B)])(aggFuncs: Rep[((A, Double) => Double)]*)(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[AggOp[A, B]] = aggOpNew[A, B](parent, numAggs, grp, aggFuncs: _*)(typeA, typeB)
  // IR defs
  val AggOpNew = AggOpIRs.AggOpNew
  type AggOpNew[A, B] = AggOpIRs.AggOpNew[A, B]
  val AggOpOpen = AggOpIRs.AggOpOpen
  type AggOpOpen[A, B] = AggOpIRs.AggOpOpen[A, B]
  val AggOpInit = AggOpIRs.AggOpInit
  type AggOpInit[A, B] = AggOpIRs.AggOpInit[A, B]
  val AggOpReset = AggOpIRs.AggOpReset
  type AggOpReset[A, B] = AggOpIRs.AggOpReset[A, B]
  val AggOpConsume = AggOpIRs.AggOpConsume
  type AggOpConsume[A, B] = AggOpIRs.AggOpConsume[A, B]
  val AggOp_Field_Hm = AggOpIRs.AggOp_Field_Hm
  type AggOp_Field_Hm[A, B] = AggOpIRs.AggOp_Field_Hm[A, B]
  val AggOp_Field_AggFuncs = AggOpIRs.AggOp_Field_AggFuncs
  type AggOp_Field_AggFuncs[A, B] = AggOpIRs.AggOp_Field_AggFuncs[A, B]
  val AggOp_Field_Grp = AggOpIRs.AggOp_Field_Grp
  type AggOp_Field_Grp[A, B] = AggOpIRs.AggOp_Field_Grp[A, B]
  val AggOp_Field_NumAggs = AggOpIRs.AggOp_Field_NumAggs
  type AggOp_Field_NumAggs[A, B] = AggOpIRs.AggOp_Field_NumAggs[A, B]
  val AggOp_Field_Parent = AggOpIRs.AggOp_Field_Parent
  type AggOp_Field_Parent[A, B] = AggOpIRs.AggOp_Field_Parent[A, B]
  val AggOp_Field_Stop__eq = AggOpIRs.AggOp_Field_Stop__eq
  type AggOp_Field_Stop__eq[A, B] = AggOpIRs.AggOp_Field_Stop__eq[A, B]
  val AggOp_Field_Stop = AggOpIRs.AggOp_Field_Stop
  type AggOp_Field_Stop[A, B] = AggOpIRs.AggOp_Field_Stop[A, B]
  val AggOp_Field_Child__eq = AggOpIRs.AggOp_Field_Child__eq
  type AggOp_Field_Child__eq[A, B] = AggOpIRs.AggOp_Field_Child__eq[A, B]
  val AggOp_Field_Child = AggOpIRs.AggOp_Field_Child
  type AggOp_Field_Child[A, B] = AggOpIRs.AggOp_Field_Child[A, B]
  // method definitions
  def aggOpNew[A, B](parent: Rep[Operator[A]], numAggs: Rep[Int], grp: Rep[((A) => B)], aggFuncs: Rep[((A, Double) => Double)]*)(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[AggOp[A, B]] = {
    val aggFuncsOutput = __liftSeq(aggFuncs.toSeq)
    AggOpNew[A, B](parent, numAggs, grp, aggFuncsOutput)
  }
  def aggOpOpen[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = AggOpOpen[A, B](self)
  def aggOpInit[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = AggOpInit[A, B](self)
  def aggOpReset[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = AggOpReset[A, B](self)
  def aggOpConsume[A, B](self: Rep[AggOp[A, B]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = AggOpConsume[A, B](self, tuple)
  def aggOp_Field_Hm[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[HashMap[B, AGGRecord[B]]] = AggOp_Field_Hm[A, B](self)
  def aggOp_Field_AggFuncs[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Seq[((A, Double) => Double)]] = AggOp_Field_AggFuncs[A, B](self)
  def aggOp_Field_Grp[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[(A => B)] = AggOp_Field_Grp[A, B](self)
  def aggOp_Field_NumAggs[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] = AggOp_Field_NumAggs[A, B](self)
  def aggOp_Field_Parent[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[A]] = AggOp_Field_Parent[A, B](self)
  def aggOp_Field_Stop_$eq[A, B](self: Rep[AggOp[A, B]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = AggOp_Field_Stop__eq[A, B](self, x$1)
  def aggOp_Field_Stop[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Boolean] = AggOp_Field_Stop[A, B](self)
  def aggOp_Field_Child_$eq[A, B](self: Rep[AggOp[A, B]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = AggOp_Field_Child__eq[A, B](self, x$1)
  def aggOp_Field_Child[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[Any]] = AggOp_Field_Child[A, B](self)
  type AggOp[A, B] = ch.epfl.data.dblab.queryengine.push.AggOp[A, B]
}
object AggOpIRs extends Base {
  import HashMapIRs._
  import AGGRecordIRs._
  import OperatorIRs._
  // Type representation
  case class AggOpType[A, B](typeA: TypeRep[A], typeB: TypeRep[B]) extends TypeRep[AggOp[A, B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = AggOpType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]])
    val name = s"AggOp[${typeA.name}, ${typeB.name}]"
    val typeArguments = List(typeA, typeB)
  }
  implicit def typeAggOp[A: TypeRep, B: TypeRep]: TypeRep[AggOp[A, B]] = AggOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  // case classes
  case class AggOpNew[A, B](parent: Rep[Operator[A]], numAggs: Rep[Int], grp: Rep[((A) => B)], aggFuncsOutput: Rep[Seq[((A, Double) => Double)]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends ConstructorDef[AggOp[A, B]](List(typeA, typeB), "AggOp", List(List(parent, numAggs), List(grp), List(__varArg(aggFuncsOutput)))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class AggOpOpen[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class AggOpInit[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class AggOpReset[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class AggOpConsume[A, B](self: Rep[AggOp[A, B]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class AggOp_Field_Hm[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[HashMap[B, AGGRecord[B]]](self, "hm") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): HashMap[B, AGGRecord[B]] = {
      val self = children(0).asInstanceOf[AggOp[A, B]]
      self.hm
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class AggOp_Field_AggFuncs[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Seq[((A, Double) => Double)]](self, "aggFuncs") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Seq[((A, Double) => Double)] = {
      val self = children(0).asInstanceOf[AggOp[A, B]]
      self.aggFuncs
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class AggOp_Field_Grp[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[(A => B)](self, "grp") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (A => B) = {
      val self = children(0).asInstanceOf[AggOp[A, B]]
      self.grp
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class AggOp_Field_NumAggs[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Int](self, "numAggs") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class AggOp_Field_Parent[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class AggOp_Field_Stop__eq[A, B](self: Rep[AggOp[A, B]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class AggOp_Field_Stop[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class AggOp_Field_Child__eq[A, B](self: Rep[AggOp[A, B]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class AggOp_Field_Child[A, B](self: Rep[AggOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B] _)
  }

  type AggOp[A, B] = ch.epfl.data.dblab.queryengine.push.AggOp[A, B]
}
trait AggOpImplicits extends AggOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait AggOpComponent extends AggOpOps with AggOpImplicits { this: OperatorsComponent => }

trait AggOpImplementations extends AggOpOps { this: OperatorsComponent =>
  override def aggOpOpen[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def aggOpInit[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    {
      self.parent.init();
      self.hm.foreach[Unit](__lambda(((pair: this.Rep[(B, ch.epfl.data.dblab.queryengine.AGGRecord[B])]) => self.child.consume(pair._2))))
    }
  }
  override def aggOpReset[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    {
      self.parent.reset();
      self.open()
    }
  }
  override def aggOpConsume[A, B](self: Rep[AggOp[A, B]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    {
      val key: this.Rep[B] = __app[A, B](self.grp).apply(infix_asInstanceOf[A](tuple));
      val elem: this.Rep[ch.epfl.data.dblab.queryengine.AGGRecord[B]] = self.hm.getOrElseUpdate(key, __newAGGRecord(key, __newArray[Double](self.numAggs)));
      val aggs: this.Rep[Array[Double]] = elem.aggs;
      var i: this.Var[Int] = __newVarNamed(unit(0), unit("i"));
      self.aggFuncs.foreach[Unit](__lambda(((aggFun: this.Rep[(A, Double) => Double]) => {
        aggs.update(__readVar(i), __app[A, Double, Double](aggFun).apply(infix_asInstanceOf[A](tuple), aggs.apply(__readVar(i))));
        __assign(i, __readVar(i).$plus(unit(1)))
      })))
    }
  }
}

trait AggOpPartialEvaluation extends AggOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def aggOp_Field_AggFuncs[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Seq[((A, Double) => Double)]] = self match {
    case Def(node: AggOpNew[_, _]) => node.aggFuncsOutput
    case _                         => super.aggOp_Field_AggFuncs[A, B](self)(typeA, typeB)
  }
  override def aggOp_Field_Grp[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[(A => B)] = self match {
    case Def(node: AggOpNew[_, _]) => node.grp
    case _                         => super.aggOp_Field_Grp[A, B](self)(typeA, typeB)
  }
  override def aggOp_Field_NumAggs[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] = self match {
    case Def(node: AggOpNew[_, _]) => node.numAggs
    case _                         => super.aggOp_Field_NumAggs[A, B](self)(typeA, typeB)
  }
  override def aggOp_Field_Parent[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[A]] = self match {
    case Def(node: AggOpNew[_, _]) => node.parent
    case _                         => super.aggOp_Field_Parent[A, B](self)(typeA, typeB)
  }

  // Mutable field inlining 
  override def aggOp_Field_Child_$eq[A, B](self: Rep[AggOp[A, B]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def aggOp_Field_Child[A, B](self: Rep[AggOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait MapOpOps extends Base with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val MapOpType = MapOpIRs.MapOpType
  type MapOpType[A] = MapOpIRs.MapOpType[A]
  implicit def typeMapOp[A: TypeRep]: TypeRep[MapOp[A]] = MapOpType(implicitly[TypeRep[A]])
  implicit class MapOpRep[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]) {
    def reset(): Rep[Unit] = mapOpReset[A](self)(typeA)
    def open(): Rep[Unit] = mapOpOpen[A](self)(typeA)
    def init(): Rep[Unit] = mapOpInit[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = mapOpConsume[A](self, tuple)(typeA)
    def run(): Rep[Unit] = mapOpRun[A](self)(typeA)
    def mapFuncs: Rep[Seq[(A => Unit)]] = mapOp_Field_MapFuncs[A](self)(typeA)
    def parent: Rep[Operator[A]] = mapOp_Field_Parent[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = mapOp_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = mapOp_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = mapOp_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = mapOp_Field_Child[A](self)(typeA)
  }
  object MapOp {

  }
  // constructors
  def __newMapOp[A](parent: Rep[Operator[A]])(mapFuncs: Rep[(A => Unit)]*)(implicit typeA: TypeRep[A]): Rep[MapOp[A]] = mapOpNew[A](parent, mapFuncs: _*)(typeA)
  // IR defs
  val MapOpNew = MapOpIRs.MapOpNew
  type MapOpNew[A] = MapOpIRs.MapOpNew[A]
  val MapOpReset = MapOpIRs.MapOpReset
  type MapOpReset[A] = MapOpIRs.MapOpReset[A]
  val MapOpOpen = MapOpIRs.MapOpOpen
  type MapOpOpen[A] = MapOpIRs.MapOpOpen[A]
  val MapOpInit = MapOpIRs.MapOpInit
  type MapOpInit[A] = MapOpIRs.MapOpInit[A]
  val MapOpConsume = MapOpIRs.MapOpConsume
  type MapOpConsume[A] = MapOpIRs.MapOpConsume[A]
  val MapOpRun = MapOpIRs.MapOpRun
  type MapOpRun[A] = MapOpIRs.MapOpRun[A]
  val MapOp_Field_MapFuncs = MapOpIRs.MapOp_Field_MapFuncs
  type MapOp_Field_MapFuncs[A] = MapOpIRs.MapOp_Field_MapFuncs[A]
  val MapOp_Field_Parent = MapOpIRs.MapOp_Field_Parent
  type MapOp_Field_Parent[A] = MapOpIRs.MapOp_Field_Parent[A]
  val MapOp_Field_Stop__eq = MapOpIRs.MapOp_Field_Stop__eq
  type MapOp_Field_Stop__eq[A] = MapOpIRs.MapOp_Field_Stop__eq[A]
  val MapOp_Field_Stop = MapOpIRs.MapOp_Field_Stop
  type MapOp_Field_Stop[A] = MapOpIRs.MapOp_Field_Stop[A]
  val MapOp_Field_Child__eq = MapOpIRs.MapOp_Field_Child__eq
  type MapOp_Field_Child__eq[A] = MapOpIRs.MapOp_Field_Child__eq[A]
  val MapOp_Field_Child = MapOpIRs.MapOp_Field_Child
  type MapOp_Field_Child[A] = MapOpIRs.MapOp_Field_Child[A]
  // method definitions
  def mapOpNew[A](parent: Rep[Operator[A]], mapFuncs: Rep[((A) => Unit)]*)(implicit typeA: TypeRep[A]): Rep[MapOp[A]] = {
    val mapFuncsOutput = __liftSeq(mapFuncs.toSeq)
    MapOpNew[A](parent, mapFuncsOutput)
  }
  def mapOpReset[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOpReset[A](self)
  def mapOpOpen[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOpOpen[A](self)
  def mapOpInit[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOpInit[A](self)
  def mapOpConsume[A](self: Rep[MapOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOpConsume[A](self, tuple)
  def mapOpRun[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOpRun[A](self)
  def mapOp_Field_MapFuncs[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Seq[(A => Unit)]] = MapOp_Field_MapFuncs[A](self)
  def mapOp_Field_Parent[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = MapOp_Field_Parent[A](self)
  def mapOp_Field_Stop_$eq[A](self: Rep[MapOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOp_Field_Stop__eq[A](self, x$1)
  def mapOp_Field_Stop[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = MapOp_Field_Stop[A](self)
  def mapOp_Field_Child_$eq[A](self: Rep[MapOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = MapOp_Field_Child__eq[A](self, x$1)
  def mapOp_Field_Child[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = MapOp_Field_Child[A](self)
  type MapOp[A] = ch.epfl.data.dblab.queryengine.push.MapOp[A]
}
object MapOpIRs extends Base {
  import OperatorIRs._
  // Type representation
  case class MapOpType[A](typeA: TypeRep[A]) extends TypeRep[MapOp[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = MapOpType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"MapOp[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeMapOp[A: TypeRep]: TypeRep[MapOp[A]] = MapOpType(implicitly[TypeRep[A]])
  // case classes
  case class MapOpNew[A](parent: Rep[Operator[A]], mapFuncsOutput: Rep[Seq[((A) => Unit)]])(implicit val typeA: TypeRep[A]) extends ConstructorDef[MapOp[A]](List(typeA), "MapOp", List(List(parent), List(__varArg(mapFuncsOutput)))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class MapOpReset[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class MapOpOpen[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class MapOpInit[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class MapOpConsume[A](self: Rep[MapOp[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class MapOpRun[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "run", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class MapOp_Field_MapFuncs[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Seq[(A => Unit)]](self, "mapFuncs") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class MapOp_Field_Parent[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class MapOp_Field_Stop__eq[A](self: Rep[MapOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class MapOp_Field_Stop[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class MapOp_Field_Child__eq[A](self: Rep[MapOp[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class MapOp_Field_Child[A](self: Rep[MapOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type MapOp[A] = ch.epfl.data.dblab.queryengine.push.MapOp[A]
}
trait MapOpImplicits extends MapOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait MapOpComponent extends MapOpOps with MapOpImplicits { this: OperatorsComponent => }

trait MapOpImplementations extends MapOpOps { this: OperatorsComponent =>
  override def mapOpReset[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.parent.reset()
  }
  override def mapOpOpen[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def mapOpInit[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.parent.init()
  }
  override def mapOpConsume[A](self: Rep[MapOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.mapFuncs.foreach[Unit](__lambda(((mf: this.Rep[A => Unit]) => __app[A, Unit](mf).apply(infix_asInstanceOf[A](tuple)))));
      __ifThenElse(infix_$bang$eq(self.child, unit(null)), self.child.consume(tuple), unit(()))
    }
  }
  override def mapOpRun[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.open();
      self.init()
    }
  }
}

trait MapOpPartialEvaluation extends MapOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def mapOp_Field_MapFuncs[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Seq[(A => Unit)]] = self match {
    case Def(node: MapOpNew[_]) => node.mapFuncsOutput
    case _                      => super.mapOp_Field_MapFuncs[A](self)(typeA)
  }
  override def mapOp_Field_Parent[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = self match {
    case Def(node: MapOpNew[_]) => node.parent
    case _                      => super.mapOp_Field_Parent[A](self)(typeA)
  }

  // Mutable field inlining 
  override def mapOp_Field_Child_$eq[A](self: Rep[MapOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def mapOp_Field_Child[A](self: Rep[MapOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait SortOpOps extends Base with TreeSetOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val SortOpType = SortOpIRs.SortOpType
  type SortOpType[A] = SortOpIRs.SortOpType[A]
  implicit def typeSortOp[A: TypeRep]: TypeRep[SortOp[A]] = SortOpType(implicitly[TypeRep[A]])
  implicit class SortOpRep[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]) {
    def init(): Rep[Unit] = sortOpInit[A](self)(typeA)
    def reset(): Rep[Unit] = sortOpReset[A](self)(typeA)
    def open(): Rep[Unit] = sortOpOpen[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = sortOpConsume[A](self, tuple)(typeA)
    def sortedTree: Rep[TreeSet[A]] = sortOp_Field_SortedTree[A](self)(typeA)
    def orderingFunc: Rep[((A, A) => Int)] = sortOp_Field_OrderingFunc[A](self)(typeA)
    def parent: Rep[Operator[A]] = sortOp_Field_Parent[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = sortOp_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = sortOp_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = sortOp_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = sortOp_Field_Child[A](self)(typeA)
  }
  object SortOp {

  }
  // constructors
  def __newSortOp[A](parent: Rep[Operator[A]])(orderingFunc: Rep[((A, A) => Int)])(implicit typeA: TypeRep[A]): Rep[SortOp[A]] = sortOpNew[A](parent, orderingFunc)(typeA)
  // IR defs
  val SortOpNew = SortOpIRs.SortOpNew
  type SortOpNew[A] = SortOpIRs.SortOpNew[A]
  val SortOpInit = SortOpIRs.SortOpInit
  type SortOpInit[A] = SortOpIRs.SortOpInit[A]
  val SortOpReset = SortOpIRs.SortOpReset
  type SortOpReset[A] = SortOpIRs.SortOpReset[A]
  val SortOpOpen = SortOpIRs.SortOpOpen
  type SortOpOpen[A] = SortOpIRs.SortOpOpen[A]
  val SortOpConsume = SortOpIRs.SortOpConsume
  type SortOpConsume[A] = SortOpIRs.SortOpConsume[A]
  val SortOp_Field_SortedTree = SortOpIRs.SortOp_Field_SortedTree
  type SortOp_Field_SortedTree[A] = SortOpIRs.SortOp_Field_SortedTree[A]
  val SortOp_Field_OrderingFunc = SortOpIRs.SortOp_Field_OrderingFunc
  type SortOp_Field_OrderingFunc[A] = SortOpIRs.SortOp_Field_OrderingFunc[A]
  val SortOp_Field_Parent = SortOpIRs.SortOp_Field_Parent
  type SortOp_Field_Parent[A] = SortOpIRs.SortOp_Field_Parent[A]
  val SortOp_Field_Stop__eq = SortOpIRs.SortOp_Field_Stop__eq
  type SortOp_Field_Stop__eq[A] = SortOpIRs.SortOp_Field_Stop__eq[A]
  val SortOp_Field_Stop = SortOpIRs.SortOp_Field_Stop
  type SortOp_Field_Stop[A] = SortOpIRs.SortOp_Field_Stop[A]
  val SortOp_Field_Child__eq = SortOpIRs.SortOp_Field_Child__eq
  type SortOp_Field_Child__eq[A] = SortOpIRs.SortOp_Field_Child__eq[A]
  val SortOp_Field_Child = SortOpIRs.SortOp_Field_Child
  type SortOp_Field_Child[A] = SortOpIRs.SortOp_Field_Child[A]
  // method definitions
  def sortOpNew[A](parent: Rep[Operator[A]], orderingFunc: Rep[((A, A) => Int)])(implicit typeA: TypeRep[A]): Rep[SortOp[A]] = SortOpNew[A](parent, orderingFunc)
  def sortOpInit[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SortOpInit[A](self)
  def sortOpReset[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SortOpReset[A](self)
  def sortOpOpen[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SortOpOpen[A](self)
  def sortOpConsume[A](self: Rep[SortOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = SortOpConsume[A](self, tuple)
  def sortOp_Field_SortedTree[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[TreeSet[A]] = SortOp_Field_SortedTree[A](self)
  def sortOp_Field_OrderingFunc[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[((A, A) => Int)] = SortOp_Field_OrderingFunc[A](self)
  def sortOp_Field_Parent[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = SortOp_Field_Parent[A](self)
  def sortOp_Field_Stop_$eq[A](self: Rep[SortOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = SortOp_Field_Stop__eq[A](self, x$1)
  def sortOp_Field_Stop[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = SortOp_Field_Stop[A](self)
  def sortOp_Field_Child_$eq[A](self: Rep[SortOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = SortOp_Field_Child__eq[A](self, x$1)
  def sortOp_Field_Child[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = SortOp_Field_Child[A](self)
  type SortOp[A] = ch.epfl.data.dblab.queryengine.push.SortOp[A]
}
object SortOpIRs extends Base {
  import TreeSetIRs._
  import OperatorIRs._
  // Type representation
  case class SortOpType[A](typeA: TypeRep[A]) extends TypeRep[SortOp[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = SortOpType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"SortOp[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeSortOp[A: TypeRep]: TypeRep[SortOp[A]] = SortOpType(implicitly[TypeRep[A]])
  // case classes
  case class SortOpNew[A](parent: Rep[Operator[A]], orderingFunc: Rep[((A, A) => Int)])(implicit val typeA: TypeRep[A]) extends ConstructorDef[SortOp[A]](List(typeA), "SortOp", List(List(parent), List(orderingFunc))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SortOpInit[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SortOpReset[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SortOpOpen[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SortOpConsume[A](self: Rep[SortOp[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SortOp_Field_SortedTree[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[TreeSet[A]](self, "sortedTree") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): TreeSet[A] = {
      val self = children(0).asInstanceOf[SortOp[A]]
      self.sortedTree
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class SortOp_Field_OrderingFunc[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[((A, A) => Int)](self, "orderingFunc") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class SortOp_Field_Parent[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class SortOp_Field_Stop__eq[A](self: Rep[SortOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SortOp_Field_Stop[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class SortOp_Field_Child__eq[A](self: Rep[SortOp[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SortOp_Field_Child[A](self: Rep[SortOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type SortOp[A] = ch.epfl.data.dblab.queryengine.push.SortOp[A]
}
trait SortOpImplicits extends SortOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait SortOpComponent extends SortOpOps with SortOpImplicits { this: OperatorsComponent => }

trait SortOpImplementations extends SortOpOps { this: OperatorsComponent =>
  override def sortOpInit[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.init();
      __whileDo(self.stop.unary_$bang.$amp$amp(infix_$bang$eq(self.sortedTree.size, unit(0))), {
        val elem: this.Rep[A] = self.sortedTree.head;
        self.sortedTree.$minus$eq(elem);
        self.child.consume(infix_asInstanceOf[ch.epfl.data.sc.pardis.shallow.Record](elem))
      })
    }
  }
  override def sortOpReset[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.reset();
      self.open()
    }
  }
  override def sortOpOpen[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def sortOpConsume[A](self: Rep[SortOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    {
      self.sortedTree.$plus$eq(infix_asInstanceOf[A](tuple));
      unit(())
    }
  }
}

trait SortOpPartialEvaluation extends SortOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def sortOp_Field_OrderingFunc[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[((A, A) => Int)] = self match {
    case Def(node: SortOpNew[_]) => node.orderingFunc
    case _                       => super.sortOp_Field_OrderingFunc[A](self)(typeA)
  }
  override def sortOp_Field_Parent[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = self match {
    case Def(node: SortOpNew[_]) => node.parent
    case _                       => super.sortOp_Field_Parent[A](self)(typeA)
  }

  // Mutable field inlining 
  override def sortOp_Field_Child_$eq[A](self: Rep[SortOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def sortOp_Field_Child[A](self: Rep[SortOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait HashJoinOpOps extends Base with MultiMapOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val HashJoinOpType = HashJoinOpIRs.HashJoinOpType
  type HashJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpType[A, B, C]
  implicit def typeHashJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, C: TypeRep]: TypeRep[HashJoinOp[A, B, C]] = HashJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class HashJoinOpRep[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) {
    def reset(): Rep[Unit] = hashJoinOpReset[A, B, C](self)(typeA, typeB, typeC)
    def open(): Rep[Unit] = hashJoinOpOpen[A, B, C](self)(typeA, typeB, typeC)
    def init(): Rep[Unit] = hashJoinOpInit[A, B, C](self)(typeA, typeB, typeC)
    def consume(tuple: Rep[Record]): Rep[Unit] = hashJoinOpConsume[A, B, C](self, tuple)(typeA, typeB, typeC)
    def hm: Rep[MultiMap[C, A]] = hashJoinOp_Field_Hm[A, B, C](self)(typeA, typeB, typeC)
    def mode_=(x$1: Rep[Int]): Rep[Unit] = hashJoinOp_Field_Mode_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def mode: Rep[Int] = hashJoinOp_Field_Mode[A, B, C](self)(typeA, typeB, typeC)
    def rightHash: Rep[(B => C)] = hashJoinOp_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
    def leftHash: Rep[(A => C)] = hashJoinOp_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
    def joinCond: Rep[((A, B) => Boolean)] = hashJoinOp_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
    def rightAlias: Rep[String] = hashJoinOp_Field_RightAlias[A, B, C](self)(typeA, typeB, typeC)
    def leftAlias: Rep[String] = hashJoinOp_Field_LeftAlias[A, B, C](self)(typeA, typeB, typeC)
    def rightParent: Rep[Operator[B]] = hashJoinOp_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
    def leftParent: Rep[Operator[A]] = hashJoinOp_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = hashJoinOp_Field_Stop_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def stop: Rep[Boolean] = hashJoinOp_Field_Stop[A, B, C](self)(typeA, typeB, typeC)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = hashJoinOp_Field_Child_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def child: Rep[Operator[Any]] = hashJoinOp_Field_Child[A, B, C](self)(typeA, typeB, typeC)
  }
  object HashJoinOp {

  }
  // constructors
  def __newHashJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], leftAlias: Rep[String], rightAlias: Rep[String])(joinCond: Rep[((A, B) => Boolean)])(leftHash: Rep[(A => C)])(rightHash: Rep[(B => C)])(implicit overload1: Overloaded1, typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[HashJoinOp[A, B, C]] = hashJoinOpNew1[A, B, C](leftParent, rightParent, leftAlias, rightAlias, joinCond, leftHash, rightHash)(typeA, typeB, typeC)
  def __newHashJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]])(joinCond: Rep[((A, B) => Boolean)])(leftHash: Rep[(A => C)])(rightHash: Rep[(B => C)])(implicit overload2: Overloaded2, typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[HashJoinOp[A, B, C]] = hashJoinOpNew2[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)(typeA, typeB, typeC)
  // IR defs
  val HashJoinOpNew1 = HashJoinOpIRs.HashJoinOpNew1
  type HashJoinOpNew1[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpNew1[A, B, C]
  val HashJoinOpNew2 = HashJoinOpIRs.HashJoinOpNew2
  type HashJoinOpNew2[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpNew2[A, B, C]
  val HashJoinOpReset = HashJoinOpIRs.HashJoinOpReset
  type HashJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpReset[A, B, C]
  val HashJoinOpOpen = HashJoinOpIRs.HashJoinOpOpen
  type HashJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpOpen[A, B, C]
  val HashJoinOpInit = HashJoinOpIRs.HashJoinOpInit
  type HashJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpInit[A, B, C]
  val HashJoinOpConsume = HashJoinOpIRs.HashJoinOpConsume
  type HashJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOpConsume[A, B, C]
  val HashJoinOp_Field_Hm = HashJoinOpIRs.HashJoinOp_Field_Hm
  type HashJoinOp_Field_Hm[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Hm[A, B, C]
  val HashJoinOp_Field_Mode__eq = HashJoinOpIRs.HashJoinOp_Field_Mode__eq
  type HashJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Mode__eq[A, B, C]
  val HashJoinOp_Field_Mode = HashJoinOpIRs.HashJoinOp_Field_Mode
  type HashJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Mode[A, B, C]
  val HashJoinOp_Field_RightHash = HashJoinOpIRs.HashJoinOp_Field_RightHash
  type HashJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_RightHash[A, B, C]
  val HashJoinOp_Field_LeftHash = HashJoinOpIRs.HashJoinOp_Field_LeftHash
  type HashJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_LeftHash[A, B, C]
  val HashJoinOp_Field_JoinCond = HashJoinOpIRs.HashJoinOp_Field_JoinCond
  type HashJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_JoinCond[A, B, C]
  val HashJoinOp_Field_RightAlias = HashJoinOpIRs.HashJoinOp_Field_RightAlias
  type HashJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_RightAlias[A, B, C]
  val HashJoinOp_Field_LeftAlias = HashJoinOpIRs.HashJoinOp_Field_LeftAlias
  type HashJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_LeftAlias[A, B, C]
  val HashJoinOp_Field_RightParent = HashJoinOpIRs.HashJoinOp_Field_RightParent
  type HashJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_RightParent[A, B, C]
  val HashJoinOp_Field_LeftParent = HashJoinOpIRs.HashJoinOp_Field_LeftParent
  type HashJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_LeftParent[A, B, C]
  val HashJoinOp_Field_Stop__eq = HashJoinOpIRs.HashJoinOp_Field_Stop__eq
  type HashJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Stop__eq[A, B, C]
  val HashJoinOp_Field_Stop = HashJoinOpIRs.HashJoinOp_Field_Stop
  type HashJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Stop[A, B, C]
  val HashJoinOp_Field_Child__eq = HashJoinOpIRs.HashJoinOp_Field_Child__eq
  type HashJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Child__eq[A, B, C]
  val HashJoinOp_Field_Child = HashJoinOpIRs.HashJoinOp_Field_Child
  type HashJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = HashJoinOpIRs.HashJoinOp_Field_Child[A, B, C]
  // method definitions
  def hashJoinOpNew1[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], leftAlias: Rep[String], rightAlias: Rep[String], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[HashJoinOp[A, B, C]] = HashJoinOpNew1[A, B, C](leftParent, rightParent, leftAlias, rightAlias, joinCond, leftHash, rightHash)
  def hashJoinOpNew2[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[HashJoinOp[A, B, C]] = HashJoinOpNew2[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)
  def hashJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOpReset[A, B, C](self)
  def hashJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOpOpen[A, B, C](self)
  def hashJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOpInit[A, B, C](self)
  def hashJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOpConsume[A, B, C](self, tuple)
  def hashJoinOp_Field_Hm[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[MultiMap[C, A]] = HashJoinOp_Field_Hm[A, B, C](self)
  def hashJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOp_Field_Mode__eq[A, B, C](self, x$1)
  def hashJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] = HashJoinOp_Field_Mode[A, B, C](self)
  def hashJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = HashJoinOp_Field_RightHash[A, B, C](self)
  def hashJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = HashJoinOp_Field_LeftHash[A, B, C](self)
  def hashJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = HashJoinOp_Field_JoinCond[A, B, C](self)
  def hashJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[String] = HashJoinOp_Field_RightAlias[A, B, C](self)
  def hashJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[String] = HashJoinOp_Field_LeftAlias[A, B, C](self)
  def hashJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = HashJoinOp_Field_RightParent[A, B, C](self)
  def hashJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = HashJoinOp_Field_LeftParent[A, B, C](self)
  def hashJoinOp_Field_Stop_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOp_Field_Stop__eq[A, B, C](self, x$1)
  def hashJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Boolean] = HashJoinOp_Field_Stop[A, B, C](self)
  def hashJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinOp_Field_Child__eq[A, B, C](self, x$1)
  def hashJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] = HashJoinOp_Field_Child[A, B, C](self)
  type HashJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = ch.epfl.data.dblab.queryengine.push.HashJoinOp[A, B, C]
}
object HashJoinOpIRs extends Base {
  import MultiMapIRs._
  import OperatorIRs._
  // Type representation
  case class HashJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[HashJoinOp[A, B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = HashJoinOpType(newArguments(0).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]], newArguments(1).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]], newArguments(2).asInstanceOf[TypeRep[_]])
    val name = s"HashJoinOp[${typeA.name}, ${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeA, typeB, typeC)
  }
  implicit def typeHashJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, C: TypeRep]: TypeRep[HashJoinOp[A, B, C]] = HashJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  // case classes
  case class HashJoinOpNew1[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], leftAlias: Rep[String], rightAlias: Rep[String], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[HashJoinOp[A, B, C]](List(typeA, typeB, typeC), "HashJoinOp", List(List(leftParent, rightParent, leftAlias, rightAlias), List(joinCond), List(leftHash), List(rightHash))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinOpNew2[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[HashJoinOp[A, B, C]](List(typeA, typeB, typeC), "HashJoinOp", List(List(leftParent, rightParent), List(joinCond), List(leftHash), List(rightHash))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinOp_Field_Hm[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[MultiMap[C, A]](self, "hm") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): MultiMap[C, A] = {
      val self = children(0).asInstanceOf[HashJoinOp[A, B, C]]
      self.hm
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Int](self, "mode", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Int](self, "mode") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(B => C)](self, "rightHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (B => C) = {
      val self = children(0).asInstanceOf[HashJoinOp[A, B, C]]
      self.rightHash
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(A => C)](self, "leftHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (A => C) = {
      val self = children(0).asInstanceOf[HashJoinOp[A, B, C]]
      self.leftHash
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[((A, B) => Boolean)](self, "joinCond") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): ((A, B) => Boolean) = {
      val self = children(0).asInstanceOf[HashJoinOp[A, B, C]]
      self.joinCond
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[String](self, "rightAlias") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[String](self, "leftAlias") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[B]](self, "rightParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Operator[B] = {
      val self = children(0).asInstanceOf[HashJoinOp[A, B, C]]
      self.rightParent
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[A]](self, "leftParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Operator[A] = {
      val self = children(0).asInstanceOf[HashJoinOp[A, B, C]]
      self.leftParent
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  type HashJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = ch.epfl.data.dblab.queryengine.push.HashJoinOp[A, B, C]
}
trait HashJoinOpImplicits extends HashJoinOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait HashJoinOpComponent extends HashJoinOpOps with HashJoinOpImplicits { this: OperatorsComponent => }

trait HashJoinOpImplementations extends HashJoinOpOps { this: OperatorsComponent =>
  override def hashJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.rightParent.reset();
      self.leftParent.reset();
      self.hm.clear()
    }
  }
  override def hashJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.leftParent.child_$eq(self);
      self.rightParent.child_$eq(self);
      self.leftParent.open();
      self.rightParent.open()
    }
  }
  override def hashJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.leftParent.init();
      self.mode_$eq(self.mode.$plus(unit(1)));
      self.rightParent.init();
      self.mode_$eq(self.mode.$plus(unit(1)))
    }
  }
  override def hashJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    __ifThenElse(infix_$eq$eq(self.mode, unit(0)), {
      val k: this.Rep[C] = __app[A, C](self.leftHash).apply(infix_asInstanceOf[A](tuple));
      {
        self.hm.addBinding(k, infix_asInstanceOf[A](tuple));
        unit(())
      }
    }, __ifThenElse(infix_$eq$eq(self.mode, unit(1)), {
      val k: this.Rep[C] = __app[B, C](self.rightHash).apply(infix_asInstanceOf[B](tuple));
      self.hm.get(k).foreach[Unit](__lambda(((tmpBuffer: this.Rep[scala.collection.mutable.Set[A]]) => tmpBuffer.foreach[Unit](__lambda(((bufElem: this.Rep[A]) => __ifThenElse(__app[A, B, Boolean](self.joinCond).apply(bufElem, infix_asInstanceOf[B](tuple)), {
        val res: this.Rep[ch.epfl.data.sc.pardis.shallow.DynamicCompositeRecord[A, B]] = RecordOps[A](bufElem).concatenateDynamic[B](infix_asInstanceOf[B](tuple), self.leftAlias, self.rightAlias);
        self.child.consume(res)
      }, unit(()))))))))
    }, unit(())))
  }
}

trait HashJoinOpPartialEvaluation extends HashJoinOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def hashJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.rightHash
    case Def(node: HashJoinOpNew2[_, _, _]) => node.rightHash
    case _                                  => super.hashJoinOp_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.leftHash
    case Def(node: HashJoinOpNew2[_, _, _]) => node.leftHash
    case _                                  => super.hashJoinOp_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.joinCond
    case Def(node: HashJoinOpNew2[_, _, _]) => node.joinCond
    case _                                  => super.hashJoinOp_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[String] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.rightAlias
    case _                                  => super.hashJoinOp_Field_RightAlias[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[String] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.leftAlias
    case _                                  => super.hashJoinOp_Field_LeftAlias[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.rightParent
    case Def(node: HashJoinOpNew2[_, _, _]) => node.rightParent
    case _                                  => super.hashJoinOp_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = self match {
    case Def(node: HashJoinOpNew1[_, _, _]) => node.leftParent
    case Def(node: HashJoinOpNew2[_, _, _]) => node.leftParent
    case _                                  => super.hashJoinOp_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
  }

  // Mutable field inlining 
  override def hashJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "mode") = x$1
    unit(())
  }

  override def hashJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] =
    mutableFieldValues.get(self -> "mode").getOrElse(unit(0)).asInstanceOf[Rep[Int]]
  override def hashJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def hashJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[HashJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait WindowOpOps extends Base with MultiMapOps with SetOps with WindowRecordOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val WindowOpType = WindowOpIRs.WindowOpType
  type WindowOpType[A, B, C] = WindowOpIRs.WindowOpType[A, B, C]
  implicit def typeWindowOp[A: TypeRep, B: TypeRep, C: TypeRep]: TypeRep[WindowOp[A, B, C]] = WindowOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class WindowOpRep[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) {
    def open(): Rep[Unit] = windowOpOpen[A, B, C](self)(typeA, typeB, typeC)
    def reset(): Rep[Unit] = windowOpReset[A, B, C](self)(typeA, typeB, typeC)
    def init(): Rep[Unit] = windowOpInit[A, B, C](self)(typeA, typeB, typeC)
    def consume(tuple: Rep[Record]): Rep[Unit] = windowOpConsume[A, B, C](self, tuple)(typeA, typeB, typeC)
    def hm: Rep[MultiMap[B, A]] = windowOp_Field_Hm[A, B, C](self)(typeA, typeB, typeC)
    def wndf: Rep[(Set[A] => C)] = windowOp_Field_Wndf[A, B, C](self)(typeA, typeB, typeC)
    def grp: Rep[(A => B)] = windowOp_Field_Grp[A, B, C](self)(typeA, typeB, typeC)
    def parent: Rep[Operator[A]] = windowOp_Field_Parent[A, B, C](self)(typeA, typeB, typeC)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = windowOp_Field_Stop_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def stop: Rep[Boolean] = windowOp_Field_Stop[A, B, C](self)(typeA, typeB, typeC)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = windowOp_Field_Child_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def child: Rep[Operator[Any]] = windowOp_Field_Child[A, B, C](self)(typeA, typeB, typeC)
  }
  object WindowOp {

  }
  // constructors
  def __newWindowOp[A, B, C](parent: Rep[Operator[A]])(grp: Rep[(A => B)])(wndf: Rep[(Set[A] => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowOp[A, B, C]] = windowOpNew[A, B, C](parent, grp, wndf)(typeA, typeB, typeC)
  // IR defs
  val WindowOpNew = WindowOpIRs.WindowOpNew
  type WindowOpNew[A, B, C] = WindowOpIRs.WindowOpNew[A, B, C]
  val WindowOpOpen = WindowOpIRs.WindowOpOpen
  type WindowOpOpen[A, B, C] = WindowOpIRs.WindowOpOpen[A, B, C]
  val WindowOpReset = WindowOpIRs.WindowOpReset
  type WindowOpReset[A, B, C] = WindowOpIRs.WindowOpReset[A, B, C]
  val WindowOpInit = WindowOpIRs.WindowOpInit
  type WindowOpInit[A, B, C] = WindowOpIRs.WindowOpInit[A, B, C]
  val WindowOpConsume = WindowOpIRs.WindowOpConsume
  type WindowOpConsume[A, B, C] = WindowOpIRs.WindowOpConsume[A, B, C]
  val WindowOp_Field_Hm = WindowOpIRs.WindowOp_Field_Hm
  type WindowOp_Field_Hm[A, B, C] = WindowOpIRs.WindowOp_Field_Hm[A, B, C]
  val WindowOp_Field_Wndf = WindowOpIRs.WindowOp_Field_Wndf
  type WindowOp_Field_Wndf[A, B, C] = WindowOpIRs.WindowOp_Field_Wndf[A, B, C]
  val WindowOp_Field_Grp = WindowOpIRs.WindowOp_Field_Grp
  type WindowOp_Field_Grp[A, B, C] = WindowOpIRs.WindowOp_Field_Grp[A, B, C]
  val WindowOp_Field_Parent = WindowOpIRs.WindowOp_Field_Parent
  type WindowOp_Field_Parent[A, B, C] = WindowOpIRs.WindowOp_Field_Parent[A, B, C]
  val WindowOp_Field_Stop__eq = WindowOpIRs.WindowOp_Field_Stop__eq
  type WindowOp_Field_Stop__eq[A, B, C] = WindowOpIRs.WindowOp_Field_Stop__eq[A, B, C]
  val WindowOp_Field_Stop = WindowOpIRs.WindowOp_Field_Stop
  type WindowOp_Field_Stop[A, B, C] = WindowOpIRs.WindowOp_Field_Stop[A, B, C]
  val WindowOp_Field_Child__eq = WindowOpIRs.WindowOp_Field_Child__eq
  type WindowOp_Field_Child__eq[A, B, C] = WindowOpIRs.WindowOp_Field_Child__eq[A, B, C]
  val WindowOp_Field_Child = WindowOpIRs.WindowOp_Field_Child
  type WindowOp_Field_Child[A, B, C] = WindowOpIRs.WindowOp_Field_Child[A, B, C]
  // method definitions
  def windowOpNew[A, B, C](parent: Rep[Operator[A]], grp: Rep[((A) => B)], wndf: Rep[((Set[A]) => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[WindowOp[A, B, C]] = WindowOpNew[A, B, C](parent, grp, wndf)
  def windowOpOpen[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = WindowOpOpen[A, B, C](self)
  def windowOpReset[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = WindowOpReset[A, B, C](self)
  def windowOpInit[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = WindowOpInit[A, B, C](self)
  def windowOpConsume[A, B, C](self: Rep[WindowOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = WindowOpConsume[A, B, C](self, tuple)
  def windowOp_Field_Hm[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[MultiMap[B, A]] = WindowOp_Field_Hm[A, B, C](self)
  def windowOp_Field_Wndf[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(Set[A] => C)] = WindowOp_Field_Wndf[A, B, C](self)
  def windowOp_Field_Grp[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => B)] = WindowOp_Field_Grp[A, B, C](self)
  def windowOp_Field_Parent[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = WindowOp_Field_Parent[A, B, C](self)
  def windowOp_Field_Stop_$eq[A, B, C](self: Rep[WindowOp[A, B, C]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = WindowOp_Field_Stop__eq[A, B, C](self, x$1)
  def windowOp_Field_Stop[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Boolean] = WindowOp_Field_Stop[A, B, C](self)
  def windowOp_Field_Child_$eq[A, B, C](self: Rep[WindowOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = WindowOp_Field_Child__eq[A, B, C](self, x$1)
  def windowOp_Field_Child[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] = WindowOp_Field_Child[A, B, C](self)
  type WindowOp[A, B, C] = ch.epfl.data.dblab.queryengine.push.WindowOp[A, B, C]
}
object WindowOpIRs extends Base {
  import MultiMapIRs._
  import SetIRs._
  import WindowRecordIRs._
  import OperatorIRs._
  // Type representation
  case class WindowOpType[A, B, C](typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[WindowOp[A, B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = WindowOpType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]], newArguments(2).asInstanceOf[TypeRep[_]])
    val name = s"WindowOp[${typeA.name}, ${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeA, typeB, typeC)
  }
  implicit def typeWindowOp[A: TypeRep, B: TypeRep, C: TypeRep]: TypeRep[WindowOp[A, B, C]] = WindowOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  // case classes
  case class WindowOpNew[A, B, C](parent: Rep[Operator[A]], grp: Rep[((A) => B)], wndf: Rep[((Set[A]) => C)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[WindowOp[A, B, C]](List(typeA, typeB, typeC), "WindowOp", List(List(parent), List(grp), List(wndf))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class WindowOpOpen[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class WindowOpReset[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class WindowOpInit[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class WindowOpConsume[A, B, C](self: Rep[WindowOp[A, B, C]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class WindowOp_Field_Hm[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[MultiMap[B, A]](self, "hm") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): MultiMap[B, A] = {
      val self = children(0).asInstanceOf[WindowOp[A, B, C]]
      self.hm
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class WindowOp_Field_Wndf[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(Set[A] => C)](self, "wndf") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (Set[A] => C) = {
      val self = children(0).asInstanceOf[WindowOp[A, B, C]]
      self.wndf
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class WindowOp_Field_Grp[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(A => B)](self, "grp") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (A => B) = {
      val self = children(0).asInstanceOf[WindowOp[A, B, C]]
      self.grp
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class WindowOp_Field_Parent[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class WindowOp_Field_Stop__eq[A, B, C](self: Rep[WindowOp[A, B, C]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class WindowOp_Field_Stop[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class WindowOp_Field_Child__eq[A, B, C](self: Rep[WindowOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class WindowOp_Field_Child[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  type WindowOp[A, B, C] = ch.epfl.data.dblab.queryengine.push.WindowOp[A, B, C]
}
trait WindowOpImplicits extends WindowOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait WindowOpComponent extends WindowOpOps with WindowOpImplicits { this: OperatorsComponent => }

trait WindowOpImplementations extends WindowOpOps { this: OperatorsComponent =>
  override def windowOpOpen[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def windowOpReset[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.parent.reset();
      self.hm.clear();
      self.open()
    }
  }
  override def windowOpInit[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.parent.init();
      self.hm.foreach[Unit](__lambda(((pair: this.Rep[(B, scala.collection.mutable.Set[A])]) => {
        val elem: this.Rep[scala.collection.mutable.Set[A]] = pair._2;
        val wnd: this.Rep[C] = __app[Set[A], C](self.wndf).apply(elem);
        val key: this.Rep[B] = __app[A, B](self.grp).apply(elem.head);
        self.child.consume(__newWindowRecord[B, C](key, wnd))
      })))
    }
  }
  override def windowOpConsume[A, B, C](self: Rep[WindowOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      val key: this.Rep[B] = __app[A, B](self.grp).apply(infix_asInstanceOf[A](tuple));
      {
        self.hm.addBinding(key, infix_asInstanceOf[A](tuple));
        unit(())
      }
    }
  }
}

trait WindowOpPartialEvaluation extends WindowOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def windowOp_Field_Wndf[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(Set[A] => C)] = self match {
    case Def(node: WindowOpNew[_, _, _]) => node.wndf
    case _                               => super.windowOp_Field_Wndf[A, B, C](self)(typeA, typeB, typeC)
  }
  override def windowOp_Field_Grp[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => B)] = self match {
    case Def(node: WindowOpNew[_, _, _]) => node.grp
    case _                               => super.windowOp_Field_Grp[A, B, C](self)(typeA, typeB, typeC)
  }
  override def windowOp_Field_Parent[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = self match {
    case Def(node: WindowOpNew[_, _, _]) => node.parent
    case _                               => super.windowOp_Field_Parent[A, B, C](self)(typeA, typeB, typeC)
  }

  // Mutable field inlining 
  override def windowOp_Field_Child_$eq[A, B, C](self: Rep[WindowOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def windowOp_Field_Child[A, B, C](self: Rep[WindowOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait LeftHashSemiJoinOpOps extends Base with MultiMapOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val LeftHashSemiJoinOpType = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpType
  type LeftHashSemiJoinOpType[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpType[A, B, C]
  implicit def typeLeftHashSemiJoinOp[A: TypeRep, B: TypeRep, C: TypeRep]: TypeRep[LeftHashSemiJoinOp[A, B, C]] = LeftHashSemiJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class LeftHashSemiJoinOpRep[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) {
    def open(): Rep[Unit] = leftHashSemiJoinOpOpen[A, B, C](self)(typeA, typeB, typeC)
    def reset(): Rep[Unit] = leftHashSemiJoinOpReset[A, B, C](self)(typeA, typeB, typeC)
    def init(): Rep[Unit] = leftHashSemiJoinOpInit[A, B, C](self)(typeA, typeB, typeC)
    def consume(tuple: Rep[Record]): Rep[Unit] = leftHashSemiJoinOpConsume[A, B, C](self, tuple)(typeA, typeB, typeC)
    def hm: Rep[MultiMap[C, B]] = leftHashSemiJoinOp_Field_Hm[A, B, C](self)(typeA, typeB, typeC)
    def mode_=(x$1: Rep[Int]): Rep[Unit] = leftHashSemiJoinOp_Field_Mode_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def mode: Rep[Int] = leftHashSemiJoinOp_Field_Mode[A, B, C](self)(typeA, typeB, typeC)
    def rightHash: Rep[(B => C)] = leftHashSemiJoinOp_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
    def leftHash: Rep[(A => C)] = leftHashSemiJoinOp_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
    def joinCond: Rep[((A, B) => Boolean)] = leftHashSemiJoinOp_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
    def rightParent: Rep[Operator[B]] = leftHashSemiJoinOp_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
    def leftParent: Rep[Operator[A]] = leftHashSemiJoinOp_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = leftHashSemiJoinOp_Field_Stop_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def stop: Rep[Boolean] = leftHashSemiJoinOp_Field_Stop[A, B, C](self)(typeA, typeB, typeC)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = leftHashSemiJoinOp_Field_Child_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def child: Rep[Operator[Any]] = leftHashSemiJoinOp_Field_Child[A, B, C](self)(typeA, typeB, typeC)
  }
  object LeftHashSemiJoinOp {

  }
  // constructors
  def __newLeftHashSemiJoinOp[A, B, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]])(joinCond: Rep[((A, B) => Boolean)])(leftHash: Rep[(A => C)])(rightHash: Rep[(B => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[LeftHashSemiJoinOp[A, B, C]] = leftHashSemiJoinOpNew[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)(typeA, typeB, typeC)
  // IR defs
  val LeftHashSemiJoinOpNew = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpNew
  type LeftHashSemiJoinOpNew[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpNew[A, B, C]
  val LeftHashSemiJoinOpOpen = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpOpen
  type LeftHashSemiJoinOpOpen[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpOpen[A, B, C]
  val LeftHashSemiJoinOpReset = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpReset
  type LeftHashSemiJoinOpReset[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpReset[A, B, C]
  val LeftHashSemiJoinOpInit = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpInit
  type LeftHashSemiJoinOpInit[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpInit[A, B, C]
  val LeftHashSemiJoinOpConsume = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpConsume
  type LeftHashSemiJoinOpConsume[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOpConsume[A, B, C]
  val LeftHashSemiJoinOp_Field_Hm = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Hm
  type LeftHashSemiJoinOp_Field_Hm[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Hm[A, B, C]
  val LeftHashSemiJoinOp_Field_Mode__eq = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Mode__eq
  type LeftHashSemiJoinOp_Field_Mode__eq[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Mode__eq[A, B, C]
  val LeftHashSemiJoinOp_Field_Mode = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Mode
  type LeftHashSemiJoinOp_Field_Mode[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Mode[A, B, C]
  val LeftHashSemiJoinOp_Field_RightHash = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_RightHash
  type LeftHashSemiJoinOp_Field_RightHash[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_RightHash[A, B, C]
  val LeftHashSemiJoinOp_Field_LeftHash = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_LeftHash
  type LeftHashSemiJoinOp_Field_LeftHash[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_LeftHash[A, B, C]
  val LeftHashSemiJoinOp_Field_JoinCond = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_JoinCond
  type LeftHashSemiJoinOp_Field_JoinCond[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_JoinCond[A, B, C]
  val LeftHashSemiJoinOp_Field_RightParent = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_RightParent
  type LeftHashSemiJoinOp_Field_RightParent[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_RightParent[A, B, C]
  val LeftHashSemiJoinOp_Field_LeftParent = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_LeftParent
  type LeftHashSemiJoinOp_Field_LeftParent[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_LeftParent[A, B, C]
  val LeftHashSemiJoinOp_Field_Stop__eq = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Stop__eq
  type LeftHashSemiJoinOp_Field_Stop__eq[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Stop__eq[A, B, C]
  val LeftHashSemiJoinOp_Field_Stop = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Stop
  type LeftHashSemiJoinOp_Field_Stop[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Stop[A, B, C]
  val LeftHashSemiJoinOp_Field_Child__eq = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Child__eq
  type LeftHashSemiJoinOp_Field_Child__eq[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Child__eq[A, B, C]
  val LeftHashSemiJoinOp_Field_Child = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Child
  type LeftHashSemiJoinOp_Field_Child[A, B, C] = LeftHashSemiJoinOpIRs.LeftHashSemiJoinOp_Field_Child[A, B, C]
  // method definitions
  def leftHashSemiJoinOpNew[A, B, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[LeftHashSemiJoinOp[A, B, C]] = LeftHashSemiJoinOpNew[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)
  def leftHashSemiJoinOpOpen[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOpOpen[A, B, C](self)
  def leftHashSemiJoinOpReset[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOpReset[A, B, C](self)
  def leftHashSemiJoinOpInit[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOpInit[A, B, C](self)
  def leftHashSemiJoinOpConsume[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOpConsume[A, B, C](self, tuple)
  def leftHashSemiJoinOp_Field_Hm[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[MultiMap[C, B]] = LeftHashSemiJoinOp_Field_Hm[A, B, C](self)
  def leftHashSemiJoinOp_Field_Mode_$eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOp_Field_Mode__eq[A, B, C](self, x$1)
  def leftHashSemiJoinOp_Field_Mode[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] = LeftHashSemiJoinOp_Field_Mode[A, B, C](self)
  def leftHashSemiJoinOp_Field_RightHash[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = LeftHashSemiJoinOp_Field_RightHash[A, B, C](self)
  def leftHashSemiJoinOp_Field_LeftHash[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = LeftHashSemiJoinOp_Field_LeftHash[A, B, C](self)
  def leftHashSemiJoinOp_Field_JoinCond[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = LeftHashSemiJoinOp_Field_JoinCond[A, B, C](self)
  def leftHashSemiJoinOp_Field_RightParent[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = LeftHashSemiJoinOp_Field_RightParent[A, B, C](self)
  def leftHashSemiJoinOp_Field_LeftParent[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = LeftHashSemiJoinOp_Field_LeftParent[A, B, C](self)
  def leftHashSemiJoinOp_Field_Stop_$eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOp_Field_Stop__eq[A, B, C](self, x$1)
  def leftHashSemiJoinOp_Field_Stop[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Boolean] = LeftHashSemiJoinOp_Field_Stop[A, B, C](self)
  def leftHashSemiJoinOp_Field_Child_$eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftHashSemiJoinOp_Field_Child__eq[A, B, C](self, x$1)
  def leftHashSemiJoinOp_Field_Child[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] = LeftHashSemiJoinOp_Field_Child[A, B, C](self)
  type LeftHashSemiJoinOp[A, B, C] = ch.epfl.data.dblab.queryengine.push.LeftHashSemiJoinOp[A, B, C]
}
object LeftHashSemiJoinOpIRs extends Base {
  import MultiMapIRs._
  import OperatorIRs._
  // Type representation
  case class LeftHashSemiJoinOpType[A, B, C](typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[LeftHashSemiJoinOp[A, B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = LeftHashSemiJoinOpType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]], newArguments(2).asInstanceOf[TypeRep[_]])
    val name = s"LeftHashSemiJoinOp[${typeA.name}, ${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeA, typeB, typeC)
  }
  implicit def typeLeftHashSemiJoinOp[A: TypeRep, B: TypeRep, C: TypeRep]: TypeRep[LeftHashSemiJoinOp[A, B, C]] = LeftHashSemiJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  // case classes
  case class LeftHashSemiJoinOpNew[A, B, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends ConstructorDef[LeftHashSemiJoinOp[A, B, C]](List(typeA, typeB, typeC), "LeftHashSemiJoinOp", List(List(leftParent, rightParent), List(joinCond), List(leftHash), List(rightHash))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftHashSemiJoinOpOpen[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftHashSemiJoinOpReset[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftHashSemiJoinOpInit[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftHashSemiJoinOpConsume[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftHashSemiJoinOp_Field_Hm[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[MultiMap[C, B]](self, "hm") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): MultiMap[C, B] = {
      val self = children(0).asInstanceOf[LeftHashSemiJoinOp[A, B, C]]
      self.hm
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftHashSemiJoinOp_Field_Mode__eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Int](self, "mode", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftHashSemiJoinOp_Field_Mode[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Int](self, "mode") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftHashSemiJoinOp_Field_RightHash[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(B => C)](self, "rightHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class LeftHashSemiJoinOp_Field_LeftHash[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(A => C)](self, "leftHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class LeftHashSemiJoinOp_Field_JoinCond[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[((A, B) => Boolean)](self, "joinCond") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class LeftHashSemiJoinOp_Field_RightParent[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[B]](self, "rightParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class LeftHashSemiJoinOp_Field_LeftParent[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[A]](self, "leftParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class LeftHashSemiJoinOp_Field_Stop__eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftHashSemiJoinOp_Field_Stop[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftHashSemiJoinOp_Field_Child__eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftHashSemiJoinOp_Field_Child[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  type LeftHashSemiJoinOp[A, B, C] = ch.epfl.data.dblab.queryengine.push.LeftHashSemiJoinOp[A, B, C]
}
trait LeftHashSemiJoinOpImplicits extends LeftHashSemiJoinOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait LeftHashSemiJoinOpComponent extends LeftHashSemiJoinOpOps with LeftHashSemiJoinOpImplicits { this: OperatorsComponent => }

trait LeftHashSemiJoinOpImplementations extends LeftHashSemiJoinOpOps { this: OperatorsComponent =>
  override def leftHashSemiJoinOpOpen[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.leftParent.child_$eq(self);
      self.rightParent.child_$eq(self);
      self.leftParent.open();
      self.rightParent.open()
    }
  }
  override def leftHashSemiJoinOpReset[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.rightParent.reset();
      self.leftParent.reset();
      self.hm.clear()
    }
  }
  override def leftHashSemiJoinOpInit[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    {
      self.rightParent.init();
      self.mode_$eq(unit(1));
      self.leftParent.init()
    }
  }
  override def leftHashSemiJoinOpConsume[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    __ifThenElse(infix_$eq$eq(self.mode, unit(0)), {
      val k: this.Rep[C] = __app[B, C](self.rightHash).apply(infix_asInstanceOf[B](tuple));
      {
        self.hm.addBinding(k, infix_asInstanceOf[B](tuple));
        unit(())
      }
    }, {
      val k: this.Rep[C] = __app[A, C](self.leftHash).apply(infix_asInstanceOf[A](tuple));
      self.hm.get(k).foreach[Unit](__lambda(((tmpBuffer: this.Rep[scala.collection.mutable.Set[B]]) => __ifThenElse(tmpBuffer.exists(__lambda(((elem: this.Rep[B]) => __app[A, B, Boolean](self.joinCond).apply(infix_asInstanceOf[A](tuple), elem)))), self.child.consume(infix_asInstanceOf[ch.epfl.data.sc.pardis.shallow.Record](tuple)), unit(())))))
    })
  }
}

trait LeftHashSemiJoinOpPartialEvaluation extends LeftHashSemiJoinOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def leftHashSemiJoinOp_Field_RightHash[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = self match {
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) => node.rightHash
    case _                                         => super.leftHashSemiJoinOp_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftHashSemiJoinOp_Field_LeftHash[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = self match {
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) => node.leftHash
    case _                                         => super.leftHashSemiJoinOp_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftHashSemiJoinOp_Field_JoinCond[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = self match {
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) => node.joinCond
    case _                                         => super.leftHashSemiJoinOp_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftHashSemiJoinOp_Field_RightParent[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = self match {
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) => node.rightParent
    case _                                         => super.leftHashSemiJoinOp_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftHashSemiJoinOp_Field_LeftParent[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = self match {
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) => node.leftParent
    case _                                         => super.leftHashSemiJoinOp_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
  }

  // Mutable field inlining 
  override def leftHashSemiJoinOp_Field_Mode_$eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "mode") = x$1
    unit(())
  }

  override def leftHashSemiJoinOp_Field_Mode[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] =
    mutableFieldValues.get(self -> "mode").getOrElse(unit(0)).asInstanceOf[Rep[Int]]
  override def leftHashSemiJoinOp_Field_Child_$eq[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def leftHashSemiJoinOp_Field_Child[A, B, C](self: Rep[LeftHashSemiJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait NestedLoopsJoinOpOps extends Base with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val NestedLoopsJoinOpType = NestedLoopsJoinOpIRs.NestedLoopsJoinOpType
  type NestedLoopsJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOpType[A, B]
  implicit def typeNestedLoopsJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep]: TypeRep[NestedLoopsJoinOp[A, B]] = NestedLoopsJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  implicit class NestedLoopsJoinOpRep[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]) {
    def open(): Rep[Unit] = nestedLoopsJoinOpOpen[A, B](self)(typeA, typeB)
    def reset(): Rep[Unit] = nestedLoopsJoinOpReset[A, B](self)(typeA, typeB)
    def init(): Rep[Unit] = nestedLoopsJoinOpInit[A, B](self)(typeA, typeB)
    def consume(tuple: Rep[Record]): Rep[Unit] = nestedLoopsJoinOpConsume[A, B](self, tuple)(typeA, typeB)
    def leftTuple_=(x$1: Rep[A]): Rep[Unit] = nestedLoopsJoinOp_Field_LeftTuple_$eq[A, B](self, x$1)(typeA, typeB)
    def leftTuple: Rep[A] = nestedLoopsJoinOp_Field_LeftTuple[A, B](self)(typeA, typeB)
    def mode_=(x$1: Rep[Int]): Rep[Unit] = nestedLoopsJoinOp_Field_Mode_$eq[A, B](self, x$1)(typeA, typeB)
    def mode: Rep[Int] = nestedLoopsJoinOp_Field_Mode[A, B](self)(typeA, typeB)
    def joinCond: Rep[((A, B) => Boolean)] = nestedLoopsJoinOp_Field_JoinCond[A, B](self)(typeA, typeB)
    def rightAlias: Rep[String] = nestedLoopsJoinOp_Field_RightAlias[A, B](self)(typeA, typeB)
    def leftAlias: Rep[String] = nestedLoopsJoinOp_Field_LeftAlias[A, B](self)(typeA, typeB)
    def rightParent: Rep[Operator[B]] = nestedLoopsJoinOp_Field_RightParent[A, B](self)(typeA, typeB)
    def leftParent: Rep[Operator[A]] = nestedLoopsJoinOp_Field_LeftParent[A, B](self)(typeA, typeB)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = nestedLoopsJoinOp_Field_Stop_$eq[A, B](self, x$1)(typeA, typeB)
    def stop: Rep[Boolean] = nestedLoopsJoinOp_Field_Stop[A, B](self)(typeA, typeB)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = nestedLoopsJoinOp_Field_Child_$eq[A, B](self, x$1)(typeA, typeB)
    def child: Rep[Operator[Any]] = nestedLoopsJoinOp_Field_Child[A, B](self)(typeA, typeB)
  }
  object NestedLoopsJoinOp {

  }
  // constructors
  def __newNestedLoopsJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], leftAlias: Rep[String], rightAlias: Rep[String])(joinCond: Rep[((A, B) => Boolean)])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[NestedLoopsJoinOp[A, B]] = nestedLoopsJoinOpNew[A, B](leftParent, rightParent, leftAlias, rightAlias, joinCond)(typeA, typeB)
  // IR defs
  val NestedLoopsJoinOpNew = NestedLoopsJoinOpIRs.NestedLoopsJoinOpNew
  type NestedLoopsJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOpNew[A, B]
  val NestedLoopsJoinOpOpen = NestedLoopsJoinOpIRs.NestedLoopsJoinOpOpen
  type NestedLoopsJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOpOpen[A, B]
  val NestedLoopsJoinOpReset = NestedLoopsJoinOpIRs.NestedLoopsJoinOpReset
  type NestedLoopsJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOpReset[A, B]
  val NestedLoopsJoinOpInit = NestedLoopsJoinOpIRs.NestedLoopsJoinOpInit
  type NestedLoopsJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOpInit[A, B]
  val NestedLoopsJoinOpConsume = NestedLoopsJoinOpIRs.NestedLoopsJoinOpConsume
  type NestedLoopsJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOpConsume[A, B]
  val NestedLoopsJoinOp_Field_LeftTuple__eq = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftTuple__eq
  type NestedLoopsJoinOp_Field_LeftTuple__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftTuple__eq[A, B]
  val NestedLoopsJoinOp_Field_LeftTuple = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftTuple
  type NestedLoopsJoinOp_Field_LeftTuple[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftTuple[A, B]
  val NestedLoopsJoinOp_Field_Mode__eq = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Mode__eq
  type NestedLoopsJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Mode__eq[A, B]
  val NestedLoopsJoinOp_Field_Mode = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Mode
  type NestedLoopsJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Mode[A, B]
  val NestedLoopsJoinOp_Field_JoinCond = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_JoinCond
  type NestedLoopsJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_JoinCond[A, B]
  val NestedLoopsJoinOp_Field_RightAlias = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_RightAlias
  type NestedLoopsJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_RightAlias[A, B]
  val NestedLoopsJoinOp_Field_LeftAlias = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftAlias
  type NestedLoopsJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftAlias[A, B]
  val NestedLoopsJoinOp_Field_RightParent = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_RightParent
  type NestedLoopsJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_RightParent[A, B]
  val NestedLoopsJoinOp_Field_LeftParent = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftParent
  type NestedLoopsJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_LeftParent[A, B]
  val NestedLoopsJoinOp_Field_Stop__eq = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Stop__eq
  type NestedLoopsJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Stop__eq[A, B]
  val NestedLoopsJoinOp_Field_Stop = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Stop
  type NestedLoopsJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Stop[A, B]
  val NestedLoopsJoinOp_Field_Child__eq = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Child__eq
  type NestedLoopsJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Child__eq[A, B]
  val NestedLoopsJoinOp_Field_Child = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Child
  type NestedLoopsJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = NestedLoopsJoinOpIRs.NestedLoopsJoinOp_Field_Child[A, B]
  // method definitions
  def nestedLoopsJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], leftAlias: Rep[String], rightAlias: Rep[String], joinCond: Rep[((A, B) => Boolean)])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[NestedLoopsJoinOp[A, B]] = NestedLoopsJoinOpNew[A, B](leftParent, rightParent, leftAlias, rightAlias, joinCond)
  def nestedLoopsJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOpOpen[A, B](self)
  def nestedLoopsJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOpReset[A, B](self)
  def nestedLoopsJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOpInit[A, B](self)
  def nestedLoopsJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOpConsume[A, B](self, tuple)
  def nestedLoopsJoinOp_Field_LeftTuple_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[A])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOp_Field_LeftTuple__eq[A, B](self, x$1)
  def nestedLoopsJoinOp_Field_LeftTuple[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[A] = NestedLoopsJoinOp_Field_LeftTuple[A, B](self)
  def nestedLoopsJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOp_Field_Mode__eq[A, B](self, x$1)
  def nestedLoopsJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] = NestedLoopsJoinOp_Field_Mode[A, B](self)
  def nestedLoopsJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[((A, B) => Boolean)] = NestedLoopsJoinOp_Field_JoinCond[A, B](self)
  def nestedLoopsJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[String] = NestedLoopsJoinOp_Field_RightAlias[A, B](self)
  def nestedLoopsJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[String] = NestedLoopsJoinOp_Field_LeftAlias[A, B](self)
  def nestedLoopsJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[B]] = NestedLoopsJoinOp_Field_RightParent[A, B](self)
  def nestedLoopsJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[A]] = NestedLoopsJoinOp_Field_LeftParent[A, B](self)
  def nestedLoopsJoinOp_Field_Stop_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOp_Field_Stop__eq[A, B](self, x$1)
  def nestedLoopsJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Boolean] = NestedLoopsJoinOp_Field_Stop[A, B](self)
  def nestedLoopsJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = NestedLoopsJoinOp_Field_Child__eq[A, B](self, x$1)
  def nestedLoopsJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[Any]] = NestedLoopsJoinOp_Field_Child[A, B](self)
  type NestedLoopsJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = ch.epfl.data.dblab.queryengine.push.NestedLoopsJoinOp[A, B]
}
object NestedLoopsJoinOpIRs extends Base {
  import OperatorIRs._
  // Type representation
  case class NestedLoopsJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](typeA: TypeRep[A], typeB: TypeRep[B]) extends TypeRep[NestedLoopsJoinOp[A, B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = NestedLoopsJoinOpType(newArguments(0).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]], newArguments(1).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]])
    val name = s"NestedLoopsJoinOp[${typeA.name}, ${typeB.name}]"
    val typeArguments = List(typeA, typeB)
  }
  implicit def typeNestedLoopsJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep]: TypeRep[NestedLoopsJoinOp[A, B]] = NestedLoopsJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  // case classes
  case class NestedLoopsJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], leftAlias: Rep[String], rightAlias: Rep[String], joinCond: Rep[((A, B) => Boolean)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends ConstructorDef[NestedLoopsJoinOp[A, B]](List(typeA, typeB), "NestedLoopsJoinOp", List(List(leftParent, rightParent, leftAlias, rightAlias), List(joinCond))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class NestedLoopsJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class NestedLoopsJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class NestedLoopsJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class NestedLoopsJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class NestedLoopsJoinOp_Field_LeftTuple__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[A])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[A](self, "leftTuple", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class NestedLoopsJoinOp_Field_LeftTuple[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[A](self, "leftTuple") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class NestedLoopsJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Int](self, "mode", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class NestedLoopsJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Int](self, "mode") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class NestedLoopsJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[((A, B) => Boolean)](self, "joinCond") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class NestedLoopsJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[String](self, "rightAlias") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class NestedLoopsJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[String](self, "leftAlias") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class NestedLoopsJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Operator[B]](self, "rightParent") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class NestedLoopsJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Operator[A]](self, "leftParent") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class NestedLoopsJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class NestedLoopsJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class NestedLoopsJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class NestedLoopsJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B] _)
  }

  type NestedLoopsJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = ch.epfl.data.dblab.queryengine.push.NestedLoopsJoinOp[A, B]
}
trait NestedLoopsJoinOpImplicits extends NestedLoopsJoinOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait NestedLoopsJoinOpComponent extends NestedLoopsJoinOpOps with NestedLoopsJoinOpImplicits { this: OperatorsComponent => }

trait NestedLoopsJoinOpImplementations extends NestedLoopsJoinOpOps { this: OperatorsComponent =>
  override def nestedLoopsJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    {
      self.rightParent.child_$eq(self);
      self.leftParent.child_$eq(self);
      self.rightParent.open();
      self.leftParent.open()
    }
  }
  override def nestedLoopsJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    {
      self.rightParent.reset();
      self.leftParent.reset();
      self.leftTuple_$eq(infix_asInstanceOf[A](unit(null)))
    }
  }
  override def nestedLoopsJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    self.leftParent.init()
  }
  override def nestedLoopsJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    __ifThenElse(infix_$eq$eq(self.mode, unit(0)), {
      self.leftTuple_$eq(infix_asInstanceOf[A](tuple));
      self.mode_$eq(unit(1));
      self.rightParent.init();
      self.mode_$eq(unit(0));
      self.rightParent.reset()
    }, __ifThenElse(__app[A, B, Boolean](self.joinCond).apply(self.leftTuple, infix_asInstanceOf[B](tuple)), self.child.consume(RecordOps[A](self.leftTuple).concatenateDynamic[B](infix_asInstanceOf[B](tuple), self.leftAlias, self.rightAlias)), unit(())))
  }
}

trait NestedLoopsJoinOpPartialEvaluation extends NestedLoopsJoinOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def nestedLoopsJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[((A, B) => Boolean)] = self match {
    case Def(node: NestedLoopsJoinOpNew[_, _]) => node.joinCond
    case _                                     => super.nestedLoopsJoinOp_Field_JoinCond[A, B](self)(typeA, typeB)
  }
  override def nestedLoopsJoinOp_Field_RightAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[String] = self match {
    case Def(node: NestedLoopsJoinOpNew[_, _]) => node.rightAlias
    case _                                     => super.nestedLoopsJoinOp_Field_RightAlias[A, B](self)(typeA, typeB)
  }
  override def nestedLoopsJoinOp_Field_LeftAlias[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[String] = self match {
    case Def(node: NestedLoopsJoinOpNew[_, _]) => node.leftAlias
    case _                                     => super.nestedLoopsJoinOp_Field_LeftAlias[A, B](self)(typeA, typeB)
  }
  override def nestedLoopsJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[B]] = self match {
    case Def(node: NestedLoopsJoinOpNew[_, _]) => node.rightParent
    case _                                     => super.nestedLoopsJoinOp_Field_RightParent[A, B](self)(typeA, typeB)
  }
  override def nestedLoopsJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[A]] = self match {
    case Def(node: NestedLoopsJoinOpNew[_, _]) => node.leftParent
    case _                                     => super.nestedLoopsJoinOp_Field_LeftParent[A, B](self)(typeA, typeB)
  }

  // Mutable field inlining 
  override def nestedLoopsJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    mutableFieldValues(self -> "mode") = x$1
    unit(())
  }

  override def nestedLoopsJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] =
    mutableFieldValues.get(self -> "mode").getOrElse(unit(0)).asInstanceOf[Rep[Int]]
  override def nestedLoopsJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def nestedLoopsJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[NestedLoopsJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait SubquerySingleResultOps extends Base with ExceptionOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val SubquerySingleResultType = SubquerySingleResultIRs.SubquerySingleResultType
  type SubquerySingleResultType[A] = SubquerySingleResultIRs.SubquerySingleResultType[A]
  implicit def typeSubquerySingleResult[A: TypeRep]: TypeRep[SubquerySingleResult[A]] = SubquerySingleResultType(implicitly[TypeRep[A]])
  implicit class SubquerySingleResultRep[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]) {
    def open(): Rep[Unit] = subquerySingleResultOpen[A](self)(typeA)
    def init(): Rep[Unit] = subquerySingleResultInit[A](self)(typeA)
    def reset(): Rep[Unit] = subquerySingleResultReset[A](self)(typeA)
    def consume(tuple: Rep[Record]): Rep[Unit] = subquerySingleResultConsume[A](self, tuple)(typeA)
    def getResult: Rep[A] = subquerySingleResultGetResult[A](self)(typeA)
    def result_=(x$1: Rep[A]): Rep[Unit] = subquerySingleResult_Field_Result_$eq[A](self, x$1)(typeA)
    def result: Rep[A] = subquerySingleResult_Field_Result[A](self)(typeA)
    def parent: Rep[Operator[A]] = subquerySingleResult_Field_Parent[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = subquerySingleResult_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = subquerySingleResult_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = subquerySingleResult_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = subquerySingleResult_Field_Child[A](self)(typeA)
  }
  object SubquerySingleResult {

  }
  // constructors
  def __newSubquerySingleResult[A](parent: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[SubquerySingleResult[A]] = subquerySingleResultNew[A](parent)(typeA)
  // IR defs
  val SubquerySingleResultNew = SubquerySingleResultIRs.SubquerySingleResultNew
  type SubquerySingleResultNew[A] = SubquerySingleResultIRs.SubquerySingleResultNew[A]
  val SubquerySingleResultOpen = SubquerySingleResultIRs.SubquerySingleResultOpen
  type SubquerySingleResultOpen[A] = SubquerySingleResultIRs.SubquerySingleResultOpen[A]
  val SubquerySingleResultInit = SubquerySingleResultIRs.SubquerySingleResultInit
  type SubquerySingleResultInit[A] = SubquerySingleResultIRs.SubquerySingleResultInit[A]
  val SubquerySingleResultReset = SubquerySingleResultIRs.SubquerySingleResultReset
  type SubquerySingleResultReset[A] = SubquerySingleResultIRs.SubquerySingleResultReset[A]
  val SubquerySingleResultConsume = SubquerySingleResultIRs.SubquerySingleResultConsume
  type SubquerySingleResultConsume[A] = SubquerySingleResultIRs.SubquerySingleResultConsume[A]
  val SubquerySingleResultGetResult = SubquerySingleResultIRs.SubquerySingleResultGetResult
  type SubquerySingleResultGetResult[A] = SubquerySingleResultIRs.SubquerySingleResultGetResult[A]
  val SubquerySingleResult_Field_Result__eq = SubquerySingleResultIRs.SubquerySingleResult_Field_Result__eq
  type SubquerySingleResult_Field_Result__eq[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Result__eq[A]
  val SubquerySingleResult_Field_Result = SubquerySingleResultIRs.SubquerySingleResult_Field_Result
  type SubquerySingleResult_Field_Result[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Result[A]
  val SubquerySingleResult_Field_Parent = SubquerySingleResultIRs.SubquerySingleResult_Field_Parent
  type SubquerySingleResult_Field_Parent[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Parent[A]
  val SubquerySingleResult_Field_Stop__eq = SubquerySingleResultIRs.SubquerySingleResult_Field_Stop__eq
  type SubquerySingleResult_Field_Stop__eq[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Stop__eq[A]
  val SubquerySingleResult_Field_Stop = SubquerySingleResultIRs.SubquerySingleResult_Field_Stop
  type SubquerySingleResult_Field_Stop[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Stop[A]
  val SubquerySingleResult_Field_Child__eq = SubquerySingleResultIRs.SubquerySingleResult_Field_Child__eq
  type SubquerySingleResult_Field_Child__eq[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Child__eq[A]
  val SubquerySingleResult_Field_Child = SubquerySingleResultIRs.SubquerySingleResult_Field_Child
  type SubquerySingleResult_Field_Child[A] = SubquerySingleResultIRs.SubquerySingleResult_Field_Child[A]
  // method definitions
  def subquerySingleResultNew[A](parent: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[SubquerySingleResult[A]] = SubquerySingleResultNew[A](parent)
  def subquerySingleResultOpen[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResultOpen[A](self)
  def subquerySingleResultInit[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResultInit[A](self)
  def subquerySingleResultReset[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResultReset[A](self)
  def subquerySingleResultConsume[A](self: Rep[SubquerySingleResult[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResultConsume[A](self, tuple)
  def subquerySingleResultGetResult[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[A] = SubquerySingleResultGetResult[A](self)
  def subquerySingleResult_Field_Result_$eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[A])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResult_Field_Result__eq[A](self, x$1)
  def subquerySingleResult_Field_Result[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[A] = SubquerySingleResult_Field_Result[A](self)
  def subquerySingleResult_Field_Parent[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = SubquerySingleResult_Field_Parent[A](self)
  def subquerySingleResult_Field_Stop_$eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResult_Field_Stop__eq[A](self, x$1)
  def subquerySingleResult_Field_Stop[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = SubquerySingleResult_Field_Stop[A](self)
  def subquerySingleResult_Field_Child_$eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = SubquerySingleResult_Field_Child__eq[A](self, x$1)
  def subquerySingleResult_Field_Child[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = SubquerySingleResult_Field_Child[A](self)
  type SubquerySingleResult[A] = ch.epfl.data.dblab.queryengine.push.SubquerySingleResult[A]
}
object SubquerySingleResultIRs extends Base {
  import ExceptionIRs._
  import OperatorIRs._
  // Type representation
  case class SubquerySingleResultType[A](typeA: TypeRep[A]) extends TypeRep[SubquerySingleResult[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = SubquerySingleResultType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"SubquerySingleResult[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeSubquerySingleResult[A: TypeRep]: TypeRep[SubquerySingleResult[A]] = SubquerySingleResultType(implicitly[TypeRep[A]])
  // case classes
  case class SubquerySingleResultNew[A](parent: Rep[Operator[A]])(implicit val typeA: TypeRep[A]) extends ConstructorDef[SubquerySingleResult[A]](List(typeA), "SubquerySingleResult", List(List(parent))) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResultOpen[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResultInit[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResultReset[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResultConsume[A](self: Rep[SubquerySingleResult[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SubquerySingleResultGetResult[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FunctionDef[A](Some(self), "getResult", List()) {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResult_Field_Result__eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[A])(implicit val typeA: TypeRep[A]) extends FieldSetter[A](self, "result", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SubquerySingleResult_Field_Result[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[A](self, "result") {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResult_Field_Parent[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class SubquerySingleResult_Field_Stop__eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SubquerySingleResult_Field_Stop[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class SubquerySingleResult_Field_Child__eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class SubquerySingleResult_Field_Child[A](self: Rep[SubquerySingleResult[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type SubquerySingleResult[A] = ch.epfl.data.dblab.queryengine.push.SubquerySingleResult[A]
}
trait SubquerySingleResultImplicits extends SubquerySingleResultOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait SubquerySingleResultComponent extends SubquerySingleResultOps with SubquerySingleResultImplicits { this: OperatorsComponent => }

trait SubquerySingleResultImplementations extends SubquerySingleResultOps { this: OperatorsComponent =>
  override def subquerySingleResultOpen[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    throw __newException(unit("PUSH ENGINE BUG:: Open function in SubqueryResult should never be called!!!!\n"))
  }
  override def subquerySingleResultInit[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    throw __newException(unit("PUSH ENGINE BUG:: Next function in SubqueryResult should never be called!!!!\n"))
  }
  override def subquerySingleResultReset[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    throw __newException(unit("PUSH ENGINE BUG:: Reset function in SubqueryResult should never be called!!!!\n"))
  }
  override def subquerySingleResultConsume[A](self: Rep[SubquerySingleResult[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    self.result_$eq(infix_asInstanceOf[A](tuple))
  }
  override def subquerySingleResultGetResult[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[A] = {
    {
      self.parent.child_$eq(self);
      self.parent.open();
      self.parent.init();
      self.result
    }
  }
}

trait SubquerySingleResultPartialEvaluation extends SubquerySingleResultComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def subquerySingleResult_Field_Parent[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = self match {
    case Def(node: SubquerySingleResultNew[_]) => node.parent
    case _                                     => super.subquerySingleResult_Field_Parent[A](self)(typeA)
  }

  // Mutable field inlining 
  override def subquerySingleResult_Field_Child_$eq[A](self: Rep[SubquerySingleResult[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def subquerySingleResult_Field_Child[A](self: Rep[SubquerySingleResult[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait HashJoinAntiOps extends Base with MultiMapOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val HashJoinAntiType = HashJoinAntiIRs.HashJoinAntiType
  type HashJoinAntiType[A, B, C] = HashJoinAntiIRs.HashJoinAntiType[A, B, C]
  implicit def typeHashJoinAnti[A: TypeRep, B: TypeRep, C: TypeRep]: TypeRep[HashJoinAnti[A, B, C]] = HashJoinAntiType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class HashJoinAntiRep[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]) {
    def open(): Rep[Unit] = hashJoinAntiOpen[A, B, C](self)(typeA, typeB, typeC, evidence$1)
    def reset(): Rep[Unit] = hashJoinAntiReset[A, B, C](self)(typeA, typeB, typeC, evidence$1)
    def init(): Rep[Unit] = hashJoinAntiInit[A, B, C](self)(typeA, typeB, typeC, evidence$1)
    def consume(tuple: Rep[Record]): Rep[Unit] = hashJoinAntiConsume[A, B, C](self, tuple)(typeA, typeB, typeC, evidence$1)
    def hm: Rep[MultiMap[C, A]] = hashJoinAnti_Field_Hm[A, B, C](self)(typeA, typeB, typeC)
    def mode_=(x$1: Rep[Int]): Rep[Unit] = hashJoinAnti_Field_Mode_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def mode: Rep[Int] = hashJoinAnti_Field_Mode[A, B, C](self)(typeA, typeB, typeC)
    def evidence$1: Rep[Manifest[A]] = hashJoinAnti_Field_Evidence$1[A, B, C](self)(typeA, typeB, typeC)
    def rightHash: Rep[(B => C)] = hashJoinAnti_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
    def leftHash: Rep[(A => C)] = hashJoinAnti_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
    def joinCond: Rep[((A, B) => Boolean)] = hashJoinAnti_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
    def rightParent: Rep[Operator[B]] = hashJoinAnti_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
    def leftParent: Rep[Operator[A]] = hashJoinAnti_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = hashJoinAnti_Field_Stop_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def stop: Rep[Boolean] = hashJoinAnti_Field_Stop[A, B, C](self)(typeA, typeB, typeC)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = hashJoinAnti_Field_Child_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def child: Rep[Operator[Any]] = hashJoinAnti_Field_Child[A, B, C](self)(typeA, typeB, typeC)
  }
  object HashJoinAnti {

  }
  // constructors
  def __newHashJoinAnti[A, B, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]])(joinCond: Rep[((A, B) => Boolean)])(leftHash: Rep[(A => C)])(rightHash: Rep[(B => C)])(implicit evidence$1: Manifest[A], typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[HashJoinAnti[A, B, C]] = hashJoinAntiNew[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)(typeA, typeB, typeC, evidence$1)
  // IR defs
  val HashJoinAntiNew = HashJoinAntiIRs.HashJoinAntiNew
  type HashJoinAntiNew[A, B, C] = HashJoinAntiIRs.HashJoinAntiNew[A, B, C]
  val HashJoinAntiOpen = HashJoinAntiIRs.HashJoinAntiOpen
  type HashJoinAntiOpen[A, B, C] = HashJoinAntiIRs.HashJoinAntiOpen[A, B, C]
  val HashJoinAntiReset = HashJoinAntiIRs.HashJoinAntiReset
  type HashJoinAntiReset[A, B, C] = HashJoinAntiIRs.HashJoinAntiReset[A, B, C]
  val HashJoinAntiInit = HashJoinAntiIRs.HashJoinAntiInit
  type HashJoinAntiInit[A, B, C] = HashJoinAntiIRs.HashJoinAntiInit[A, B, C]
  val HashJoinAntiConsume = HashJoinAntiIRs.HashJoinAntiConsume
  type HashJoinAntiConsume[A, B, C] = HashJoinAntiIRs.HashJoinAntiConsume[A, B, C]
  val HashJoinAnti_Field_Hm = HashJoinAntiIRs.HashJoinAnti_Field_Hm
  type HashJoinAnti_Field_Hm[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Hm[A, B, C]
  val HashJoinAnti_Field_Mode__eq = HashJoinAntiIRs.HashJoinAnti_Field_Mode__eq
  type HashJoinAnti_Field_Mode__eq[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Mode__eq[A, B, C]
  val HashJoinAnti_Field_Mode = HashJoinAntiIRs.HashJoinAnti_Field_Mode
  type HashJoinAnti_Field_Mode[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Mode[A, B, C]
  val HashJoinAnti_Field_Evidence$1 = HashJoinAntiIRs.HashJoinAnti_Field_Evidence$1
  type HashJoinAnti_Field_Evidence$1[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Evidence$1[A, B, C]
  val HashJoinAnti_Field_RightHash = HashJoinAntiIRs.HashJoinAnti_Field_RightHash
  type HashJoinAnti_Field_RightHash[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_RightHash[A, B, C]
  val HashJoinAnti_Field_LeftHash = HashJoinAntiIRs.HashJoinAnti_Field_LeftHash
  type HashJoinAnti_Field_LeftHash[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_LeftHash[A, B, C]
  val HashJoinAnti_Field_JoinCond = HashJoinAntiIRs.HashJoinAnti_Field_JoinCond
  type HashJoinAnti_Field_JoinCond[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_JoinCond[A, B, C]
  val HashJoinAnti_Field_RightParent = HashJoinAntiIRs.HashJoinAnti_Field_RightParent
  type HashJoinAnti_Field_RightParent[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_RightParent[A, B, C]
  val HashJoinAnti_Field_LeftParent = HashJoinAntiIRs.HashJoinAnti_Field_LeftParent
  type HashJoinAnti_Field_LeftParent[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_LeftParent[A, B, C]
  val HashJoinAnti_Field_Stop__eq = HashJoinAntiIRs.HashJoinAnti_Field_Stop__eq
  type HashJoinAnti_Field_Stop__eq[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Stop__eq[A, B, C]
  val HashJoinAnti_Field_Stop = HashJoinAntiIRs.HashJoinAnti_Field_Stop
  type HashJoinAnti_Field_Stop[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Stop[A, B, C]
  val HashJoinAnti_Field_Child__eq = HashJoinAntiIRs.HashJoinAnti_Field_Child__eq
  type HashJoinAnti_Field_Child__eq[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Child__eq[A, B, C]
  val HashJoinAnti_Field_Child = HashJoinAntiIRs.HashJoinAnti_Field_Child
  type HashJoinAnti_Field_Child[A, B, C] = HashJoinAntiIRs.HashJoinAnti_Field_Child[A, B, C]
  // method definitions
  def hashJoinAntiNew[A, B, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[HashJoinAnti[A, B, C]] = HashJoinAntiNew[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)
  def hashJoinAntiOpen[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = HashJoinAntiOpen[A, B, C](self)
  def hashJoinAntiReset[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = HashJoinAntiReset[A, B, C](self)
  def hashJoinAntiInit[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = HashJoinAntiInit[A, B, C](self)
  def hashJoinAntiConsume[A, B, C](self: Rep[HashJoinAnti[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = HashJoinAntiConsume[A, B, C](self, tuple)
  def hashJoinAnti_Field_Hm[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[MultiMap[C, A]] = HashJoinAnti_Field_Hm[A, B, C](self)
  def hashJoinAnti_Field_Mode_$eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinAnti_Field_Mode__eq[A, B, C](self, x$1)
  def hashJoinAnti_Field_Mode[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] = HashJoinAnti_Field_Mode[A, B, C](self)
  def hashJoinAnti_Field_Evidence$1[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Manifest[A]] = HashJoinAnti_Field_Evidence$1[A, B, C](self)
  def hashJoinAnti_Field_RightHash[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = HashJoinAnti_Field_RightHash[A, B, C](self)
  def hashJoinAnti_Field_LeftHash[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = HashJoinAnti_Field_LeftHash[A, B, C](self)
  def hashJoinAnti_Field_JoinCond[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = HashJoinAnti_Field_JoinCond[A, B, C](self)
  def hashJoinAnti_Field_RightParent[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = HashJoinAnti_Field_RightParent[A, B, C](self)
  def hashJoinAnti_Field_LeftParent[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = HashJoinAnti_Field_LeftParent[A, B, C](self)
  def hashJoinAnti_Field_Stop_$eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinAnti_Field_Stop__eq[A, B, C](self, x$1)
  def hashJoinAnti_Field_Stop[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Boolean] = HashJoinAnti_Field_Stop[A, B, C](self)
  def hashJoinAnti_Field_Child_$eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = HashJoinAnti_Field_Child__eq[A, B, C](self, x$1)
  def hashJoinAnti_Field_Child[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] = HashJoinAnti_Field_Child[A, B, C](self)
  type HashJoinAnti[A, B, C] = ch.epfl.data.dblab.queryengine.push.HashJoinAnti[A, B, C]
}
object HashJoinAntiIRs extends Base {
  import MultiMapIRs._
  import OperatorIRs._
  // Type representation
  case class HashJoinAntiType[A, B, C](typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[HashJoinAnti[A, B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = HashJoinAntiType(newArguments(0).asInstanceOf[TypeRep[_]], newArguments(1).asInstanceOf[TypeRep[_]], newArguments(2).asInstanceOf[TypeRep[_]])
    val name = s"HashJoinAnti[${typeA.name}, ${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeA, typeB, typeC)
  }
  implicit def typeHashJoinAnti[A: TypeRep, B: TypeRep, C: TypeRep]: TypeRep[HashJoinAnti[A, B, C]] = HashJoinAntiType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  // case classes
  case class HashJoinAntiNew[A, B, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$1: Manifest[A]) extends ConstructorDef[HashJoinAnti[A, B, C]](List(typeA, typeB, typeC), "HashJoinAnti", List(List(leftParent, rightParent), List(joinCond), List(leftHash), List(rightHash))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinAntiOpen[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$1: Manifest[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinAntiReset[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$1: Manifest[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinAntiInit[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$1: Manifest[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinAntiConsume[A, B, C](self: Rep[HashJoinAnti[A, B, C]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$1: Manifest[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinAnti_Field_Hm[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[MultiMap[C, A]](self, "hm") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): MultiMap[C, A] = {
      val self = children(0).asInstanceOf[HashJoinAnti[A, B, C]]
      self.hm
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class HashJoinAnti_Field_Mode__eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Int](self, "mode", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinAnti_Field_Mode[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Int](self, "mode") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinAnti_Field_Evidence$1[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Manifest[A]](self, "evidence$1") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinAnti_Field_RightHash[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(B => C)](self, "rightHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinAnti_Field_LeftHash[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(A => C)](self, "leftHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinAnti_Field_JoinCond[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[((A, B) => Boolean)](self, "joinCond") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinAnti_Field_RightParent[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[B]](self, "rightParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinAnti_Field_LeftParent[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[A]](self, "leftParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class HashJoinAnti_Field_Stop__eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinAnti_Field_Stop[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class HashJoinAnti_Field_Child__eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class HashJoinAnti_Field_Child[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  type HashJoinAnti[A, B, C] = ch.epfl.data.dblab.queryengine.push.HashJoinAnti[A, B, C]
}
trait HashJoinAntiImplicits extends HashJoinAntiOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait HashJoinAntiComponent extends HashJoinAntiOps with HashJoinAntiImplicits { this: OperatorsComponent => }

trait HashJoinAntiImplementations extends HashJoinAntiOps { this: OperatorsComponent =>
  override def hashJoinAntiOpen[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = {
    {
      self.leftParent.child_$eq(self);
      self.leftParent.open();
      self.rightParent.child_$eq(self);
      self.rightParent.open()
    }
  }
  override def hashJoinAntiReset[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = {
    {
      self.rightParent.reset();
      self.leftParent.reset();
      self.hm.clear()
    }
  }
  override def hashJoinAntiInit[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = {
    {
      self.leftParent.init();
      self.mode_$eq(unit(1));
      self.rightParent.init();
      self.hm.foreach[Unit](__lambda(((pair: this.Rep[(C, scala.collection.mutable.Set[A])]) => {
        val v: this.Rep[scala.collection.mutable.Set[A]] = pair._2;
        v.foreach[Unit](__lambda(((e: this.Rep[A]) => self.child.consume(infix_asInstanceOf[ch.epfl.data.sc.pardis.shallow.Record](e)))))
      })))
    }
  }
  override def hashJoinAntiConsume[A, B, C](self: Rep[HashJoinAnti[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$1: Manifest[A]): Rep[Unit] = {
    __ifThenElse(infix_$eq$eq(self.mode, unit(0)), {
      val t: this.Rep[A] = infix_asInstanceOf[A](tuple);
      val k: this.Rep[C] = __app[A, C](self.leftHash).apply(t);
      {
        self.hm.addBinding(k, t);
        unit(())
      }
    }, {
      val t: this.Rep[B] = infix_asInstanceOf[B](tuple);
      val k: this.Rep[C] = __app[B, C](self.rightHash).apply(t);
      self.hm.get(k).foreach[Unit](__lambda(((elems: this.Rep[scala.collection.mutable.Set[A]]) => elems.retain(__lambda(((e: this.Rep[A]) => __app[A, B, Boolean](self.joinCond).apply(e, t).unary_$bang))))))
    })
  }
}

trait HashJoinAntiPartialEvaluation extends HashJoinAntiComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def hashJoinAnti_Field_RightHash[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = self match {
    case Def(node: HashJoinAntiNew[_, _, _]) => node.rightHash
    case _                                   => super.hashJoinAnti_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinAnti_Field_LeftHash[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = self match {
    case Def(node: HashJoinAntiNew[_, _, _]) => node.leftHash
    case _                                   => super.hashJoinAnti_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinAnti_Field_JoinCond[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = self match {
    case Def(node: HashJoinAntiNew[_, _, _]) => node.joinCond
    case _                                   => super.hashJoinAnti_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinAnti_Field_RightParent[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = self match {
    case Def(node: HashJoinAntiNew[_, _, _]) => node.rightParent
    case _                                   => super.hashJoinAnti_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
  }
  override def hashJoinAnti_Field_LeftParent[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = self match {
    case Def(node: HashJoinAntiNew[_, _, _]) => node.leftParent
    case _                                   => super.hashJoinAnti_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
  }

  // Mutable field inlining 
  override def hashJoinAnti_Field_Mode_$eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "mode") = x$1
    unit(())
  }

  override def hashJoinAnti_Field_Mode[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] =
    mutableFieldValues.get(self -> "mode").getOrElse(unit(0)).asInstanceOf[Rep[Int]]
  override def hashJoinAnti_Field_Child_$eq[A, B, C](self: Rep[HashJoinAnti[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def hashJoinAnti_Field_Child[A, B, C](self: Rep[HashJoinAnti[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait ViewOpOps extends Base with ArrayOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val ViewOpType = ViewOpIRs.ViewOpType
  type ViewOpType[A] = ViewOpIRs.ViewOpType[A]
  implicit def typeViewOp[A: TypeRep]: TypeRep[ViewOp[A]] = ViewOpType(implicitly[TypeRep[A]])
  implicit class ViewOpRep[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]) {
    def open(): Rep[Unit] = viewOpOpen[A](self)(typeA, evidence$2)
    def reset(): Rep[Unit] = viewOpReset[A](self)(typeA, evidence$2)
    def init(): Rep[Unit] = viewOpInit[A](self)(typeA, evidence$2)
    def consume(tuple: Rep[Record]): Rep[Unit] = viewOpConsume[A](self, tuple)(typeA, evidence$2)
    def initialized_=(x$1: Rep[Boolean]): Rep[Unit] = viewOp_Field_Initialized_$eq[A](self, x$1)(typeA)
    def initialized: Rep[Boolean] = viewOp_Field_Initialized[A](self)(typeA)
    def table: Rep[Array[A]] = viewOp_Field_Table[A](self)(typeA)
    def size_=(x$1: Rep[Int]): Rep[Unit] = viewOp_Field_Size_$eq[A](self, x$1)(typeA)
    def size: Rep[Int] = viewOp_Field_Size[A](self)(typeA)
    def evidence$2: Rep[Manifest[A]] = viewOp_Field_Evidence$2[A](self)(typeA)
    def parent: Rep[Operator[A]] = viewOp_Field_Parent[A](self)(typeA)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = viewOp_Field_Stop_$eq[A](self, x$1)(typeA)
    def stop: Rep[Boolean] = viewOp_Field_Stop[A](self)(typeA)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = viewOp_Field_Child_$eq[A](self, x$1)(typeA)
    def child: Rep[Operator[Any]] = viewOp_Field_Child[A](self)(typeA)
  }
  object ViewOp {

  }
  // constructors
  def __newViewOp[A](parent: Rep[Operator[A]])(implicit evidence$2: Manifest[A], typeA: TypeRep[A]): Rep[ViewOp[A]] = viewOpNew[A](parent)(typeA, evidence$2)
  // IR defs
  val ViewOpNew = ViewOpIRs.ViewOpNew
  type ViewOpNew[A] = ViewOpIRs.ViewOpNew[A]
  val ViewOpOpen = ViewOpIRs.ViewOpOpen
  type ViewOpOpen[A] = ViewOpIRs.ViewOpOpen[A]
  val ViewOpReset = ViewOpIRs.ViewOpReset
  type ViewOpReset[A] = ViewOpIRs.ViewOpReset[A]
  val ViewOpInit = ViewOpIRs.ViewOpInit
  type ViewOpInit[A] = ViewOpIRs.ViewOpInit[A]
  val ViewOpConsume = ViewOpIRs.ViewOpConsume
  type ViewOpConsume[A] = ViewOpIRs.ViewOpConsume[A]
  val ViewOp_Field_Initialized__eq = ViewOpIRs.ViewOp_Field_Initialized__eq
  type ViewOp_Field_Initialized__eq[A] = ViewOpIRs.ViewOp_Field_Initialized__eq[A]
  val ViewOp_Field_Initialized = ViewOpIRs.ViewOp_Field_Initialized
  type ViewOp_Field_Initialized[A] = ViewOpIRs.ViewOp_Field_Initialized[A]
  val ViewOp_Field_Table = ViewOpIRs.ViewOp_Field_Table
  type ViewOp_Field_Table[A] = ViewOpIRs.ViewOp_Field_Table[A]
  val ViewOp_Field_Size__eq = ViewOpIRs.ViewOp_Field_Size__eq
  type ViewOp_Field_Size__eq[A] = ViewOpIRs.ViewOp_Field_Size__eq[A]
  val ViewOp_Field_Size = ViewOpIRs.ViewOp_Field_Size
  type ViewOp_Field_Size[A] = ViewOpIRs.ViewOp_Field_Size[A]
  val ViewOp_Field_Evidence$2 = ViewOpIRs.ViewOp_Field_Evidence$2
  type ViewOp_Field_Evidence$2[A] = ViewOpIRs.ViewOp_Field_Evidence$2[A]
  val ViewOp_Field_Parent = ViewOpIRs.ViewOp_Field_Parent
  type ViewOp_Field_Parent[A] = ViewOpIRs.ViewOp_Field_Parent[A]
  val ViewOp_Field_Stop__eq = ViewOpIRs.ViewOp_Field_Stop__eq
  type ViewOp_Field_Stop__eq[A] = ViewOpIRs.ViewOp_Field_Stop__eq[A]
  val ViewOp_Field_Stop = ViewOpIRs.ViewOp_Field_Stop
  type ViewOp_Field_Stop[A] = ViewOpIRs.ViewOp_Field_Stop[A]
  val ViewOp_Field_Child__eq = ViewOpIRs.ViewOp_Field_Child__eq
  type ViewOp_Field_Child__eq[A] = ViewOpIRs.ViewOp_Field_Child__eq[A]
  val ViewOp_Field_Child = ViewOpIRs.ViewOp_Field_Child
  type ViewOp_Field_Child[A] = ViewOpIRs.ViewOp_Field_Child[A]
  // method definitions
  def viewOpNew[A](parent: Rep[Operator[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[ViewOp[A]] = ViewOpNew[A](parent)
  def viewOpOpen[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = ViewOpOpen[A](self)
  def viewOpReset[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = ViewOpReset[A](self)
  def viewOpInit[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = ViewOpInit[A](self)
  def viewOpConsume[A](self: Rep[ViewOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = ViewOpConsume[A](self, tuple)
  def viewOp_Field_Initialized_$eq[A](self: Rep[ViewOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = ViewOp_Field_Initialized__eq[A](self, x$1)
  def viewOp_Field_Initialized[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = ViewOp_Field_Initialized[A](self)
  def viewOp_Field_Table[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Array[A]] = ViewOp_Field_Table[A](self)
  def viewOp_Field_Size_$eq[A](self: Rep[ViewOp[A]], x$1: Rep[Int])(implicit typeA: TypeRep[A]): Rep[Unit] = ViewOp_Field_Size__eq[A](self, x$1)
  def viewOp_Field_Size[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Int] = ViewOp_Field_Size[A](self)
  def viewOp_Field_Evidence$2[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Manifest[A]] = ViewOp_Field_Evidence$2[A](self)
  def viewOp_Field_Parent[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = ViewOp_Field_Parent[A](self)
  def viewOp_Field_Stop_$eq[A](self: Rep[ViewOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = ViewOp_Field_Stop__eq[A](self, x$1)
  def viewOp_Field_Stop[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] = ViewOp_Field_Stop[A](self)
  def viewOp_Field_Child_$eq[A](self: Rep[ViewOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = ViewOp_Field_Child__eq[A](self, x$1)
  def viewOp_Field_Child[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] = ViewOp_Field_Child[A](self)
  type ViewOp[A] = ch.epfl.data.dblab.queryengine.push.ViewOp[A]
}
object ViewOpIRs extends Base {
  import ArrayIRs._
  import OperatorIRs._
  // Type representation
  case class ViewOpType[A](typeA: TypeRep[A]) extends TypeRep[ViewOp[A]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = ViewOpType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"ViewOp[${typeA.name}]"
    val typeArguments = List(typeA)
  }
  implicit def typeViewOp[A: TypeRep]: TypeRep[ViewOp[A]] = ViewOpType(implicitly[TypeRep[A]])
  // case classes
  case class ViewOpNew[A](parent: Rep[Operator[A]])(implicit val typeA: TypeRep[A], val evidence$2: Manifest[A]) extends ConstructorDef[ViewOp[A]](List(typeA), "ViewOp", List(List(parent))) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOpOpen[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A], val evidence$2: Manifest[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOpReset[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A], val evidence$2: Manifest[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOpInit[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A], val evidence$2: Manifest[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOpConsume[A](self: Rep[ViewOp[A]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val evidence$2: Manifest[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ViewOp_Field_Initialized__eq[A](self: Rep[ViewOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "initialized", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ViewOp_Field_Initialized[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "initialized") {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOp_Field_Table[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Array[A]](self, "table") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Array[A] = {
      val self = children(0).asInstanceOf[ViewOp[A]]
      self.table
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class ViewOp_Field_Size__eq[A](self: Rep[ViewOp[A]], x$1: Rep[Int])(implicit val typeA: TypeRep[A]) extends FieldSetter[Int](self, "size", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ViewOp_Field_Size[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Int](self, "size") {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOp_Field_Evidence$2[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Manifest[A]](self, "evidence$2") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class ViewOp_Field_Parent[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldDef[Operator[A]](self, "parent") {
    override def curriedConstructor = (copy[A] _)
    override def isPure = true

  }

  case class ViewOp_Field_Stop__eq[A](self: Rep[ViewOp[A]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ViewOp_Field_Stop[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A] _)
  }

  case class ViewOp_Field_Child__eq[A](self: Rep[ViewOp[A]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A] _).curried
  }

  case class ViewOp_Field_Child[A](self: Rep[ViewOp[A]])(implicit val typeA: TypeRep[A]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A] _)
  }

  type ViewOp[A] = ch.epfl.data.dblab.queryengine.push.ViewOp[A]
}
trait ViewOpImplicits extends ViewOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait ViewOpComponent extends ViewOpOps with ViewOpImplicits { this: OperatorsComponent => }

trait ViewOpImplementations extends ViewOpOps { this: OperatorsComponent =>
  override def viewOpOpen[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = {
    {
      self.parent.child_$eq(self);
      self.parent.open()
    }
  }
  override def viewOpReset[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = {
    unit(())
  }
  override def viewOpInit[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = {
    {
      __ifThenElse(self.initialized.unary_$bang, {
        self.parent.init();
        self.initialized_$eq(unit(true))
      }, unit(()));
      var idx: this.Var[Int] = __newVarNamed(unit(0), unit("idx"));
      __whileDo(self.stop.unary_$bang.$amp$amp(__readVar(idx).$less(self.size)), {
        val e: this.Rep[A] = self.table.apply(__readVar(idx));
        __assign(idx, __readVar(idx).$plus(unit(1)));
        self.child.consume(infix_asInstanceOf[ch.epfl.data.sc.pardis.shallow.Record](e))
      })
    }
  }
  override def viewOpConsume[A](self: Rep[ViewOp[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A], evidence$2: Manifest[A]): Rep[Unit] = {
    {
      self.table.update(self.size, infix_asInstanceOf[A](tuple));
      self.size_$eq(self.size.$plus(unit(1)))
    }
  }
}

trait ViewOpPartialEvaluation extends ViewOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def viewOp_Field_Parent[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[A]] = self match {
    case Def(node: ViewOpNew[_]) => node.parent
    case _                       => super.viewOp_Field_Parent[A](self)(typeA)
  }

  // Mutable field inlining 
  override def viewOp_Field_Initialized_$eq[A](self: Rep[ViewOp[A]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "initialized") = x$1
    unit(())
  }

  override def viewOp_Field_Initialized[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Boolean] =
    mutableFieldValues.get(self -> "initialized").getOrElse(unit(false)).asInstanceOf[Rep[Boolean]]
  override def viewOp_Field_Child_$eq[A](self: Rep[ViewOp[A]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def viewOp_Field_Child[A](self: Rep[ViewOp[A]])(implicit typeA: TypeRep[A]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait LeftOuterJoinOpOps extends Base with MultiMapOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val LeftOuterJoinOpType = LeftOuterJoinOpIRs.LeftOuterJoinOpType
  type LeftOuterJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOpType[A, B, C]
  implicit def typeLeftOuterJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, C: TypeRep]: TypeRep[LeftOuterJoinOp[A, B, C]] = LeftOuterJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  implicit class LeftOuterJoinOpRep[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]) {
    def open(): Rep[Unit] = leftOuterJoinOpOpen[A, B, C](self)(typeA, typeB, typeC, evidence$3)
    def init(): Rep[Unit] = leftOuterJoinOpInit[A, B, C](self)(typeA, typeB, typeC, evidence$3)
    def reset(): Rep[Unit] = leftOuterJoinOpReset[A, B, C](self)(typeA, typeB, typeC, evidence$3)
    def consume(tuple: Rep[Record]): Rep[Unit] = leftOuterJoinOpConsume[A, B, C](self, tuple)(typeA, typeB, typeC, evidence$3)
    def defaultB: Rep[B] = leftOuterJoinOp_Field_DefaultB[A, B, C](self)(typeA, typeB, typeC)
    def hm: Rep[MultiMap[C, B]] = leftOuterJoinOp_Field_Hm[A, B, C](self)(typeA, typeB, typeC)
    def mode_=(x$1: Rep[Int]): Rep[Unit] = leftOuterJoinOp_Field_Mode_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def mode: Rep[Int] = leftOuterJoinOp_Field_Mode[A, B, C](self)(typeA, typeB, typeC)
    def evidence$3: Rep[Manifest[B]] = leftOuterJoinOp_Field_Evidence$3[A, B, C](self)(typeA, typeB, typeC)
    def rightHash: Rep[(B => C)] = leftOuterJoinOp_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
    def leftHash: Rep[(A => C)] = leftOuterJoinOp_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
    def joinCond: Rep[((A, B) => Boolean)] = leftOuterJoinOp_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
    def rightParent: Rep[Operator[B]] = leftOuterJoinOp_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
    def leftParent: Rep[Operator[A]] = leftOuterJoinOp_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = leftOuterJoinOp_Field_Stop_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def stop: Rep[Boolean] = leftOuterJoinOp_Field_Stop[A, B, C](self)(typeA, typeB, typeC)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = leftOuterJoinOp_Field_Child_$eq[A, B, C](self, x$1)(typeA, typeB, typeC)
    def child: Rep[Operator[Any]] = leftOuterJoinOp_Field_Child[A, B, C](self)(typeA, typeB, typeC)
  }
  object LeftOuterJoinOp {

  }
  // constructors
  def __newLeftOuterJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]])(joinCond: Rep[((A, B) => Boolean)])(leftHash: Rep[(A => C)])(rightHash: Rep[(B => C)])(implicit evidence$3: Manifest[B], typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[LeftOuterJoinOp[A, B, C]] = leftOuterJoinOpNew[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)(typeA, typeB, typeC, evidence$3)
  // IR defs
  val LeftOuterJoinOpNew = LeftOuterJoinOpIRs.LeftOuterJoinOpNew
  type LeftOuterJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOpNew[A, B, C]
  val LeftOuterJoinOpOpen = LeftOuterJoinOpIRs.LeftOuterJoinOpOpen
  type LeftOuterJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOpOpen[A, B, C]
  val LeftOuterJoinOpInit = LeftOuterJoinOpIRs.LeftOuterJoinOpInit
  type LeftOuterJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOpInit[A, B, C]
  val LeftOuterJoinOpReset = LeftOuterJoinOpIRs.LeftOuterJoinOpReset
  type LeftOuterJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOpReset[A, B, C]
  val LeftOuterJoinOpConsume = LeftOuterJoinOpIRs.LeftOuterJoinOpConsume
  type LeftOuterJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOpConsume[A, B, C]
  val LeftOuterJoinOp_Field_DefaultB = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_DefaultB
  type LeftOuterJoinOp_Field_DefaultB[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_DefaultB[A, B, C]
  val LeftOuterJoinOp_Field_Hm = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Hm
  type LeftOuterJoinOp_Field_Hm[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Hm[A, B, C]
  val LeftOuterJoinOp_Field_Mode__eq = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Mode__eq
  type LeftOuterJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Mode__eq[A, B, C]
  val LeftOuterJoinOp_Field_Mode = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Mode
  type LeftOuterJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Mode[A, B, C]
  val LeftOuterJoinOp_Field_Evidence$3 = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Evidence$3
  type LeftOuterJoinOp_Field_Evidence$3[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Evidence$3[A, B, C]
  val LeftOuterJoinOp_Field_RightHash = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_RightHash
  type LeftOuterJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_RightHash[A, B, C]
  val LeftOuterJoinOp_Field_LeftHash = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_LeftHash
  type LeftOuterJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_LeftHash[A, B, C]
  val LeftOuterJoinOp_Field_JoinCond = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_JoinCond
  type LeftOuterJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_JoinCond[A, B, C]
  val LeftOuterJoinOp_Field_RightParent = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_RightParent
  type LeftOuterJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_RightParent[A, B, C]
  val LeftOuterJoinOp_Field_LeftParent = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_LeftParent
  type LeftOuterJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_LeftParent[A, B, C]
  val LeftOuterJoinOp_Field_Stop__eq = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Stop__eq
  type LeftOuterJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Stop__eq[A, B, C]
  val LeftOuterJoinOp_Field_Stop = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Stop
  type LeftOuterJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Stop[A, B, C]
  val LeftOuterJoinOp_Field_Child__eq = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Child__eq
  type LeftOuterJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Child__eq[A, B, C]
  val LeftOuterJoinOp_Field_Child = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Child
  type LeftOuterJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = LeftOuterJoinOpIRs.LeftOuterJoinOp_Field_Child[A, B, C]
  // method definitions
  def leftOuterJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[LeftOuterJoinOp[A, B, C]] = LeftOuterJoinOpNew[A, B, C](leftParent, rightParent, joinCond, leftHash, rightHash)
  def leftOuterJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = LeftOuterJoinOpOpen[A, B, C](self)
  def leftOuterJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = LeftOuterJoinOpInit[A, B, C](self)
  def leftOuterJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = LeftOuterJoinOpReset[A, B, C](self)
  def leftOuterJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = LeftOuterJoinOpConsume[A, B, C](self, tuple)
  def leftOuterJoinOp_Field_DefaultB[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[B] = LeftOuterJoinOp_Field_DefaultB[A, B, C](self)
  def leftOuterJoinOp_Field_Hm[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[MultiMap[C, B]] = LeftOuterJoinOp_Field_Hm[A, B, C](self)
  def leftOuterJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftOuterJoinOp_Field_Mode__eq[A, B, C](self, x$1)
  def leftOuterJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] = LeftOuterJoinOp_Field_Mode[A, B, C](self)
  def leftOuterJoinOp_Field_Evidence$3[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Manifest[B]] = LeftOuterJoinOp_Field_Evidence$3[A, B, C](self)
  def leftOuterJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = LeftOuterJoinOp_Field_RightHash[A, B, C](self)
  def leftOuterJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = LeftOuterJoinOp_Field_LeftHash[A, B, C](self)
  def leftOuterJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = LeftOuterJoinOp_Field_JoinCond[A, B, C](self)
  def leftOuterJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = LeftOuterJoinOp_Field_RightParent[A, B, C](self)
  def leftOuterJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = LeftOuterJoinOp_Field_LeftParent[A, B, C](self)
  def leftOuterJoinOp_Field_Stop_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftOuterJoinOp_Field_Stop__eq[A, B, C](self, x$1)
  def leftOuterJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Boolean] = LeftOuterJoinOp_Field_Stop[A, B, C](self)
  def leftOuterJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = LeftOuterJoinOp_Field_Child__eq[A, B, C](self, x$1)
  def leftOuterJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] = LeftOuterJoinOp_Field_Child[A, B, C](self)
  type LeftOuterJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = ch.epfl.data.dblab.queryengine.push.LeftOuterJoinOp[A, B, C]
}
object LeftOuterJoinOpIRs extends Base {
  import MultiMapIRs._
  import OperatorIRs._
  // Type representation
  case class LeftOuterJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]) extends TypeRep[LeftOuterJoinOp[A, B, C]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = LeftOuterJoinOpType(newArguments(0).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]], newArguments(1).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]], newArguments(2).asInstanceOf[TypeRep[_]])
    val name = s"LeftOuterJoinOp[${typeA.name}, ${typeB.name}, ${typeC.name}]"
    val typeArguments = List(typeA, typeB, typeC)
  }
  implicit def typeLeftOuterJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, C: TypeRep]: TypeRep[LeftOuterJoinOp[A, B, C]] = LeftOuterJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]], implicitly[TypeRep[C]])
  // case classes
  case class LeftOuterJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Boolean)], leftHash: Rep[((A) => C)], rightHash: Rep[((B) => C)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$3: Manifest[B]) extends ConstructorDef[LeftOuterJoinOp[A, B, C]](List(typeA, typeB, typeC), "LeftOuterJoinOp", List(List(leftParent, rightParent), List(joinCond), List(leftHash), List(rightHash))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftOuterJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$3: Manifest[B]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftOuterJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$3: Manifest[B]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftOuterJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$3: Manifest[B]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftOuterJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C], val evidence$3: Manifest[B]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftOuterJoinOp_Field_DefaultB[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[B](self, "defaultB") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): B = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.defaultB
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_Hm[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[MultiMap[C, B]](self, "hm") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): MultiMap[C, B] = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.hm
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Int](self, "mode", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftOuterJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Int](self, "mode") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftOuterJoinOp_Field_Evidence$3[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Manifest[B]](self, "evidence$3") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

  }

  case class LeftOuterJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(B => C)](self, "rightHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (B => C) = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.rightHash
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[(A => C)](self, "leftHash") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): (A => C) = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.leftHash
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[((A, B) => Boolean)](self, "joinCond") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): ((A, B) => Boolean) = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.joinCond
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[B]](self, "rightParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Operator[B] = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.rightParent
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldDef[Operator[A]](self, "leftParent") {
    override def curriedConstructor = (copy[A, B, C] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Operator[A] = {
      val self = children(0).asInstanceOf[LeftOuterJoinOp[A, B, C]]
      self.leftParent
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class LeftOuterJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftOuterJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  case class LeftOuterJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B, C] _).curried
  }

  case class LeftOuterJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val typeC: TypeRep[C]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B, C] _)
  }

  type LeftOuterJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C] = ch.epfl.data.dblab.queryengine.push.LeftOuterJoinOp[A, B, C]
}
trait LeftOuterJoinOpImplicits extends LeftOuterJoinOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait LeftOuterJoinOpComponent extends LeftOuterJoinOpOps with LeftOuterJoinOpImplicits { this: OperatorsComponent => }

trait LeftOuterJoinOpImplementations extends LeftOuterJoinOpOps { this: OperatorsComponent =>
  override def leftOuterJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = {
    {
      self.leftParent.child_$eq(self);
      self.leftParent.open();
      self.rightParent.child_$eq(self);
      self.rightParent.open()
    }
  }
  override def leftOuterJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = {
    {
      self.rightParent.init();
      self.mode_$eq(unit(1));
      self.leftParent.init()
    }
  }
  override def leftOuterJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = {
    {
      self.rightParent.reset();
      self.leftParent.reset();
      self.hm.clear()
    }
  }
  override def leftOuterJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C], evidence$3: Manifest[B]): Rep[Unit] = {
    __ifThenElse(infix_$eq$eq(self.mode, unit(0)), {
      val k: this.Rep[C] = __app[B, C](self.rightHash).apply(infix_asInstanceOf[B](tuple));
      {
        self.hm.addBinding(k, infix_asInstanceOf[B](tuple));
        unit(())
      }
    }, {
      val k: this.Rep[C] = __app[A, C](self.leftHash).apply(infix_asInstanceOf[A](tuple));
      val hmGet: this.Rep[Option[scala.collection.mutable.Set[B]]] = self.hm.get(k);
      __ifThenElse(hmGet.nonEmpty, {
        val tmpBuffer: this.Rep[scala.collection.mutable.Set[B]] = hmGet.get;
        tmpBuffer.foreach[Unit](__lambda(((bufElem: this.Rep[B]) => {
          val elem: this.Rep[ch.epfl.data.sc.pardis.shallow.DynamicCompositeRecord[A, B]] = __ifThenElse(__app[A, B, Boolean](self.joinCond).apply(infix_asInstanceOf[A](tuple), bufElem), RecordOps[A](infix_asInstanceOf[A](tuple)).concatenateDynamic[B](bufElem, unit(""), unit("")), RecordOps[A](infix_asInstanceOf[A](tuple)).concatenateDynamic[B](self.defaultB, unit(""), unit("")));
          self.child.consume(elem)
        })))
      }, self.child.consume(RecordOps[A](infix_asInstanceOf[A](tuple)).concatenateDynamic[B](self.defaultB, unit(""), unit(""))))
    })
  }
}

trait LeftOuterJoinOpPartialEvaluation extends LeftOuterJoinOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def leftOuterJoinOp_Field_RightHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(B => C)] = self match {
    case Def(node: LeftOuterJoinOpNew[_, _, _]) => node.rightHash
    case _                                      => super.leftOuterJoinOp_Field_RightHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftOuterJoinOp_Field_LeftHash[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[(A => C)] = self match {
    case Def(node: LeftOuterJoinOpNew[_, _, _]) => node.leftHash
    case _                                      => super.leftOuterJoinOp_Field_LeftHash[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftOuterJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[((A, B) => Boolean)] = self match {
    case Def(node: LeftOuterJoinOpNew[_, _, _]) => node.joinCond
    case _                                      => super.leftOuterJoinOp_Field_JoinCond[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftOuterJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[B]] = self match {
    case Def(node: LeftOuterJoinOpNew[_, _, _]) => node.rightParent
    case _                                      => super.leftOuterJoinOp_Field_RightParent[A, B, C](self)(typeA, typeB, typeC)
  }
  override def leftOuterJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[A]] = self match {
    case Def(node: LeftOuterJoinOpNew[_, _, _]) => node.leftParent
    case _                                      => super.leftOuterJoinOp_Field_LeftParent[A, B, C](self)(typeA, typeB, typeC)
  }

  // Mutable field inlining 
  override def leftOuterJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "mode") = x$1
    unit(())
  }

  override def leftOuterJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Int] =
    mutableFieldValues.get(self -> "mode").getOrElse(unit(0)).asInstanceOf[Rep[Int]]
  override def leftOuterJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def leftOuterJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record, C](self: Rep[LeftOuterJoinOp[A, B, C]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], typeC: TypeRep[C]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait MergeJoinOpOps extends Base with ArrayOps with OperatorOps { this: OperatorsComponent =>
  // Type representation
  val MergeJoinOpType = MergeJoinOpIRs.MergeJoinOpType
  type MergeJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpType[A, B]
  implicit def typeMergeJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep]: TypeRep[MergeJoinOp[A, B]] = MergeJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  implicit class MergeJoinOpRep[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]) {
    def reset(): Rep[Unit] = mergeJoinOpReset[A, B](self)(typeA, typeB, evidence$4)
    def open(): Rep[Unit] = mergeJoinOpOpen[A, B](self)(typeA, typeB, evidence$4)
    def init(): Rep[Unit] = mergeJoinOpInit[A, B](self)(typeA, typeB, evidence$4)
    def consumeLeft(leftTuple: Rep[A]): Rep[Unit] = mergeJoinOpConsumeLeft[A, B](self, leftTuple)(typeA, typeB, evidence$4)
    def consumeRight(rightTuple: Rep[B]): Rep[Unit] = mergeJoinOpConsumeRight[A, B](self, rightTuple)(typeA, typeB, evidence$4)
    def consume(tuple: Rep[Record]): Rep[Unit] = mergeJoinOpConsume[A, B](self, tuple)(typeA, typeB, evidence$4)
    def leftSize_=(x$1: Rep[Int]): Rep[Unit] = mergeJoinOp_Field_LeftSize_$eq[A, B](self, x$1)(typeA, typeB)
    def leftSize: Rep[Int] = mergeJoinOp_Field_LeftSize[A, B](self)(typeA, typeB)
    def leftIndex_=(x$1: Rep[Int]): Rep[Unit] = mergeJoinOp_Field_LeftIndex_$eq[A, B](self, x$1)(typeA, typeB)
    def leftIndex: Rep[Int] = mergeJoinOp_Field_LeftIndex[A, B](self)(typeA, typeB)
    def leftRelation: Rep[Array[A]] = mergeJoinOp_Field_LeftRelation[A, B](self)(typeA, typeB)
    def mode_=(x$1: Rep[Int]): Rep[Unit] = mergeJoinOp_Field_Mode_$eq[A, B](self, x$1)(typeA, typeB)
    def mode: Rep[Int] = mergeJoinOp_Field_Mode[A, B](self)(typeA, typeB)
    def evidence$4: Rep[Manifest[A]] = mergeJoinOp_Field_Evidence$4[A, B](self)(typeA, typeB)
    def joinCond: Rep[((A, B) => Int)] = mergeJoinOp_Field_JoinCond[A, B](self)(typeA, typeB)
    def rightParent: Rep[Operator[B]] = mergeJoinOp_Field_RightParent[A, B](self)(typeA, typeB)
    def leftParent: Rep[Operator[A]] = mergeJoinOp_Field_LeftParent[A, B](self)(typeA, typeB)
    def stop_=(x$1: Rep[Boolean]): Rep[Unit] = mergeJoinOp_Field_Stop_$eq[A, B](self, x$1)(typeA, typeB)
    def stop: Rep[Boolean] = mergeJoinOp_Field_Stop[A, B](self)(typeA, typeB)
    def child_=(x$1: Rep[Operator[Any]]): Rep[Unit] = mergeJoinOp_Field_Child_$eq[A, B](self, x$1)(typeA, typeB)
    def child: Rep[Operator[Any]] = mergeJoinOp_Field_Child[A, B](self)(typeA, typeB)
  }
  object MergeJoinOp {

  }
  // constructors
  def __newMergeJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]])(joinCond: Rep[((A, B) => Int)])(implicit evidence$4: Manifest[A], typeA: TypeRep[A], typeB: TypeRep[B]): Rep[MergeJoinOp[A, B]] = mergeJoinOpNew[A, B](leftParent, rightParent, joinCond)(typeA, typeB, evidence$4)
  // IR defs
  val MergeJoinOpNew = MergeJoinOpIRs.MergeJoinOpNew
  type MergeJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpNew[A, B]
  val MergeJoinOpReset = MergeJoinOpIRs.MergeJoinOpReset
  type MergeJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpReset[A, B]
  val MergeJoinOpOpen = MergeJoinOpIRs.MergeJoinOpOpen
  type MergeJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpOpen[A, B]
  val MergeJoinOpInit = MergeJoinOpIRs.MergeJoinOpInit
  type MergeJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpInit[A, B]
  val MergeJoinOpConsumeLeft = MergeJoinOpIRs.MergeJoinOpConsumeLeft
  type MergeJoinOpConsumeLeft[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpConsumeLeft[A, B]
  val MergeJoinOpConsumeRight = MergeJoinOpIRs.MergeJoinOpConsumeRight
  type MergeJoinOpConsumeRight[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpConsumeRight[A, B]
  val MergeJoinOpConsume = MergeJoinOpIRs.MergeJoinOpConsume
  type MergeJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOpConsume[A, B]
  val MergeJoinOp_Field_LeftSize__eq = MergeJoinOpIRs.MergeJoinOp_Field_LeftSize__eq
  type MergeJoinOp_Field_LeftSize__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_LeftSize__eq[A, B]
  val MergeJoinOp_Field_LeftSize = MergeJoinOpIRs.MergeJoinOp_Field_LeftSize
  type MergeJoinOp_Field_LeftSize[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_LeftSize[A, B]
  val MergeJoinOp_Field_LeftIndex__eq = MergeJoinOpIRs.MergeJoinOp_Field_LeftIndex__eq
  type MergeJoinOp_Field_LeftIndex__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_LeftIndex__eq[A, B]
  val MergeJoinOp_Field_LeftIndex = MergeJoinOpIRs.MergeJoinOp_Field_LeftIndex
  type MergeJoinOp_Field_LeftIndex[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_LeftIndex[A, B]
  val MergeJoinOp_Field_LeftRelation = MergeJoinOpIRs.MergeJoinOp_Field_LeftRelation
  type MergeJoinOp_Field_LeftRelation[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_LeftRelation[A, B]
  val MergeJoinOp_Field_Mode__eq = MergeJoinOpIRs.MergeJoinOp_Field_Mode__eq
  type MergeJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Mode__eq[A, B]
  val MergeJoinOp_Field_Mode = MergeJoinOpIRs.MergeJoinOp_Field_Mode
  type MergeJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Mode[A, B]
  val MergeJoinOp_Field_Evidence$4 = MergeJoinOpIRs.MergeJoinOp_Field_Evidence$4
  type MergeJoinOp_Field_Evidence$4[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Evidence$4[A, B]
  val MergeJoinOp_Field_JoinCond = MergeJoinOpIRs.MergeJoinOp_Field_JoinCond
  type MergeJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_JoinCond[A, B]
  val MergeJoinOp_Field_RightParent = MergeJoinOpIRs.MergeJoinOp_Field_RightParent
  type MergeJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_RightParent[A, B]
  val MergeJoinOp_Field_LeftParent = MergeJoinOpIRs.MergeJoinOp_Field_LeftParent
  type MergeJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_LeftParent[A, B]
  val MergeJoinOp_Field_Stop__eq = MergeJoinOpIRs.MergeJoinOp_Field_Stop__eq
  type MergeJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Stop__eq[A, B]
  val MergeJoinOp_Field_Stop = MergeJoinOpIRs.MergeJoinOp_Field_Stop
  type MergeJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Stop[A, B]
  val MergeJoinOp_Field_Child__eq = MergeJoinOpIRs.MergeJoinOp_Field_Child__eq
  type MergeJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Child__eq[A, B]
  val MergeJoinOp_Field_Child = MergeJoinOpIRs.MergeJoinOp_Field_Child
  type MergeJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = MergeJoinOpIRs.MergeJoinOp_Field_Child[A, B]
  // method definitions
  def mergeJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Int)])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[MergeJoinOp[A, B]] = MergeJoinOpNew[A, B](leftParent, rightParent, joinCond)
  def mergeJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = MergeJoinOpReset[A, B](self)
  def mergeJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = MergeJoinOpOpen[A, B](self)
  def mergeJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = MergeJoinOpInit[A, B](self)
  def mergeJoinOpConsumeLeft[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], leftTuple: Rep[A])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = MergeJoinOpConsumeLeft[A, B](self, leftTuple)
  def mergeJoinOpConsumeRight[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], rightTuple: Rep[B])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = MergeJoinOpConsumeRight[A, B](self, rightTuple)
  def mergeJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = MergeJoinOpConsume[A, B](self, tuple)
  def mergeJoinOp_Field_LeftSize_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = MergeJoinOp_Field_LeftSize__eq[A, B](self, x$1)
  def mergeJoinOp_Field_LeftSize[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] = MergeJoinOp_Field_LeftSize[A, B](self)
  def mergeJoinOp_Field_LeftIndex_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = MergeJoinOp_Field_LeftIndex__eq[A, B](self, x$1)
  def mergeJoinOp_Field_LeftIndex[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] = MergeJoinOp_Field_LeftIndex[A, B](self)
  def mergeJoinOp_Field_LeftRelation[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Array[A]] = MergeJoinOp_Field_LeftRelation[A, B](self)
  def mergeJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = MergeJoinOp_Field_Mode__eq[A, B](self, x$1)
  def mergeJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] = MergeJoinOp_Field_Mode[A, B](self)
  def mergeJoinOp_Field_Evidence$4[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Manifest[A]] = MergeJoinOp_Field_Evidence$4[A, B](self)
  def mergeJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[((A, B) => Int)] = MergeJoinOp_Field_JoinCond[A, B](self)
  def mergeJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[B]] = MergeJoinOp_Field_RightParent[A, B](self)
  def mergeJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[A]] = MergeJoinOp_Field_LeftParent[A, B](self)
  def mergeJoinOp_Field_Stop_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Boolean])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = MergeJoinOp_Field_Stop__eq[A, B](self, x$1)
  def mergeJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Boolean] = MergeJoinOp_Field_Stop[A, B](self)
  def mergeJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = MergeJoinOp_Field_Child__eq[A, B](self, x$1)
  def mergeJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[Any]] = MergeJoinOp_Field_Child[A, B](self)
  type MergeJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = ch.epfl.data.dblab.queryengine.push.MergeJoinOp[A, B]
}
object MergeJoinOpIRs extends Base {
  import ArrayIRs._
  import OperatorIRs._
  // Type representation
  case class MergeJoinOpType[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](typeA: TypeRep[A], typeB: TypeRep[B]) extends TypeRep[MergeJoinOp[A, B]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = MergeJoinOpType(newArguments(0).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]], newArguments(1).asInstanceOf[TypeRep[_ <: ch.epfl.data.sc.pardis.shallow.Record]])
    val name = s"MergeJoinOp[${typeA.name}, ${typeB.name}]"
    val typeArguments = List(typeA, typeB)
  }
  implicit def typeMergeJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep, B <: ch.epfl.data.sc.pardis.shallow.Record: TypeRep]: TypeRep[MergeJoinOp[A, B]] = MergeJoinOpType(implicitly[TypeRep[A]], implicitly[TypeRep[B]])
  // case classes
  case class MergeJoinOpNew[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](leftParent: Rep[Operator[A]], rightParent: Rep[Operator[B]], joinCond: Rep[((A, B) => Int)])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends ConstructorDef[MergeJoinOp[A, B]](List(typeA, typeB), "MergeJoinOp", List(List(leftParent, rightParent), List(joinCond))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends FunctionDef[Unit](Some(self), "reset", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends FunctionDef[Unit](Some(self), "open", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends FunctionDef[Unit](Some(self), "init", List(List())) {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOpConsumeLeft[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], leftTuple: Rep[A])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends FunctionDef[Unit](Some(self), "consumeLeft", List(List(leftTuple))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOpConsumeRight[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], rightTuple: Rep[B])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends FunctionDef[Unit](Some(self), "consumeRight", List(List(rightTuple))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], tuple: Rep[Record])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B], val evidence$4: Manifest[A]) extends FunctionDef[Unit](Some(self), "consume", List(List(tuple))) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOp_Field_LeftSize__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Int](self, "leftSize", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOp_Field_LeftSize[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Int](self, "leftSize") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOp_Field_LeftIndex__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Int](self, "leftIndex", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOp_Field_LeftIndex[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Int](self, "leftIndex") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOp_Field_LeftRelation[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Array[A]](self, "leftRelation") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Array[A] = {
      val self = children(0).asInstanceOf[MergeJoinOp[A, B]]
      self.leftRelation
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class MergeJoinOp_Field_Mode__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Int](self, "mode", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Int](self, "mode") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOp_Field_Evidence$4[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Manifest[A]](self, "evidence$4") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

  }

  case class MergeJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[((A, B) => Int)](self, "joinCond") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): ((A, B) => Int) = {
      val self = children(0).asInstanceOf[MergeJoinOp[A, B]]
      self.joinCond
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class MergeJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Operator[B]](self, "rightParent") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Operator[B] = {
      val self = children(0).asInstanceOf[MergeJoinOp[A, B]]
      self.rightParent
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class MergeJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldDef[Operator[A]](self, "leftParent") {
    override def curriedConstructor = (copy[A, B] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Operator[A] = {
      val self = children(0).asInstanceOf[MergeJoinOp[A, B]]
      self.leftParent
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class MergeJoinOp_Field_Stop__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Boolean])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Boolean](self, "stop", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOp_Field_Stop[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Boolean](self, "stop") {
    override def curriedConstructor = (copy[A, B] _)
  }

  case class MergeJoinOp_Field_Child__eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Operator[Any]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldSetter[Operator[Any]](self, "child", x$1) {
    override def curriedConstructor = (copy[A, B] _).curried
  }

  case class MergeJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit val typeA: TypeRep[A], val typeB: TypeRep[B]) extends FieldGetter[Operator[Any]](self, "child") {
    override def curriedConstructor = (copy[A, B] _)
  }

  type MergeJoinOp[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record] = ch.epfl.data.dblab.queryengine.push.MergeJoinOp[A, B]
}
trait MergeJoinOpImplicits extends MergeJoinOpOps { this: OperatorsComponent =>
  // Add implicit conversions here!
}
trait MergeJoinOpComponent extends MergeJoinOpOps with MergeJoinOpImplicits { this: OperatorsComponent => }

trait MergeJoinOpImplementations extends MergeJoinOpOps { this: OperatorsComponent =>
  override def mergeJoinOpReset[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = {
    {
      self.rightParent.reset();
      self.leftParent.reset();
      self.leftSize_$eq(unit(0))
    }
  }
  override def mergeJoinOpOpen[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = {
    {
      self.leftParent.child_$eq(self);
      self.rightParent.child_$eq(self);
      self.leftParent.open();
      self.rightParent.open()
    }
  }
  override def mergeJoinOpInit[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = {
    {
      self.leftParent.init();
      self.mode_$eq(self.mode.$plus(unit(1)));
      self.rightParent.init();
      self.mode_$eq(self.mode.$plus(unit(1)))
    }
  }
  override def mergeJoinOpConsumeLeft[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], leftTuple: Rep[A])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = {
    {
      self.leftRelation.update(self.leftSize, leftTuple);
      self.leftSize_$eq(self.leftSize.$plus(unit(1)))
    }
  }
  override def mergeJoinOpConsumeRight[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], rightTuple: Rep[B])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = {
    {
      __whileDo(self.leftIndex.$less(self.leftSize).$amp$amp(__app[A, B, Int](self.joinCond).apply(self.leftRelation.apply(self.leftIndex), rightTuple).$less(unit(0))), self.leftIndex_$eq(self.leftIndex.$plus(unit(1))));
      __ifThenElse(self.leftIndex.$less(self.leftSize).$amp$amp(infix_$eq$eq(__app[A, B, Int](self.joinCond).apply(self.leftRelation.apply(self.leftIndex), rightTuple), unit(0))), {
        val res: this.Rep[ch.epfl.data.sc.pardis.shallow.DynamicCompositeRecord[A, B]] = RecordOps[A](self.leftRelation.apply(self.leftIndex)).concatenateDynamic[B](rightTuple, unit(""), unit(""));
        self.child.consume(res)
      }, unit(()))
    }
  }
  override def mergeJoinOpConsume[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], tuple: Rep[Record])(implicit typeA: TypeRep[A], typeB: TypeRep[B], evidence$4: Manifest[A]): Rep[Unit] = {
    __ifThenElse(infix_$eq$eq(self.mode, unit(0)), self.consumeLeft(infix_asInstanceOf[A](tuple)), __ifThenElse(infix_$eq$eq(self.mode, unit(1)), self.consumeRight(infix_asInstanceOf[B](tuple)), unit(())))
  }
}

trait MergeJoinOpPartialEvaluation extends MergeJoinOpComponent with BasePartialEvaluation { this: OperatorsComponent =>
  // Immutable field inlining 
  override def mergeJoinOp_Field_JoinCond[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[((A, B) => Int)] = self match {
    case Def(node: MergeJoinOpNew[_, _]) => node.joinCond
    case _                               => super.mergeJoinOp_Field_JoinCond[A, B](self)(typeA, typeB)
  }
  override def mergeJoinOp_Field_RightParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[B]] = self match {
    case Def(node: MergeJoinOpNew[_, _]) => node.rightParent
    case _                               => super.mergeJoinOp_Field_RightParent[A, B](self)(typeA, typeB)
  }
  override def mergeJoinOp_Field_LeftParent[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[A]] = self match {
    case Def(node: MergeJoinOpNew[_, _]) => node.leftParent
    case _                               => super.mergeJoinOp_Field_LeftParent[A, B](self)(typeA, typeB)
  }

  // Mutable field inlining 
  override def mergeJoinOp_Field_Mode_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Int])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    mutableFieldValues(self -> "mode") = x$1
    unit(())
  }

  override def mergeJoinOp_Field_Mode[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Int] =
    mutableFieldValues.get(self -> "mode").getOrElse(unit(0)).asInstanceOf[Rep[Int]]
  override def mergeJoinOp_Field_Child_$eq[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]], x$1: Rep[Operator[Any]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Unit] = {
    mutableFieldValues(self -> "child") = x$1
    unit(())
  }

  override def mergeJoinOp_Field_Child[A <: ch.epfl.data.sc.pardis.shallow.Record, B <: ch.epfl.data.sc.pardis.shallow.Record](self: Rep[MergeJoinOp[A, B]])(implicit typeA: TypeRep[A], typeB: TypeRep[B]): Rep[Operator[Any]] =
    mutableFieldValues.get(self -> "child").getOrElse(unit(null)).asInstanceOf[Rep[Operator[Any]]]
  // Pure function partial evaluation
}

trait OperatorDynamicDispatch extends OperatorComponent { this: OperatorsComponent =>
  override def operatorOpen[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = self match {
    case Def(node: ScanOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ScanOpNew[T1]]
      scanOpOpen[T1](self.asInstanceOf[Rep[ScanOp[T1]]])(newNode.typeA)
    case Def(node: PrintOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[PrintOpNew[T1]]
      printOpOpen[T1](self.asInstanceOf[Rep[PrintOp[T1]]])(newNode.typeA)
    case Def(node: SelectOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SelectOpNew[T1]]
      selectOpOpen[T1](self.asInstanceOf[Rep[SelectOp[T1]]])(newNode.typeA)
    case Def(node: AggOpNew[_, _]) =>
      type T1 = Any
      type T2 = Any
      val newNode = node.asInstanceOf[AggOpNew[T1, T2]]
      aggOpOpen[T1, T2](self.asInstanceOf[Rep[AggOp[T1, T2]]])(newNode.typeA, newNode.typeB)
    case Def(node: MapOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[MapOpNew[T1]]
      mapOpOpen[T1](self.asInstanceOf[Rep[MapOp[T1]]])(newNode.typeA)
    case Def(node: SortOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SortOpNew[T1]]
      sortOpOpen[T1](self.asInstanceOf[Rep[SortOp[T1]]])(newNode.typeA)
    case Def(node: HashJoinOpNew1[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew1[T1, T2, T3]]
      hashJoinOpOpen[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: HashJoinOpNew2[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew2[T1, T2, T3]]
      hashJoinOpOpen[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: WindowOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[WindowOpNew[T1, T2, T3]]
      windowOpOpen[T1, T2, T3](self.asInstanceOf[Rep[WindowOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[LeftHashSemiJoinOpNew[T1, T2, T3]]
      leftHashSemiJoinOpOpen[T1, T2, T3](self.asInstanceOf[Rep[LeftHashSemiJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: NestedLoopsJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[NestedLoopsJoinOpNew[T1, T2]]
      nestedLoopsJoinOpOpen[T1, T2](self.asInstanceOf[Rep[NestedLoopsJoinOp[T1, T2]]])(newNode.typeA, newNode.typeB)
    case Def(node: SubquerySingleResultNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SubquerySingleResultNew[T1]]
      subquerySingleResultOpen[T1](self.asInstanceOf[Rep[SubquerySingleResult[T1]]])(newNode.typeA)
    case Def(node: HashJoinAntiNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinAntiNew[T1, T2, T3]]
      hashJoinAntiOpen[T1, T2, T3](self.asInstanceOf[Rep[HashJoinAnti[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$1)
    case Def(node: ViewOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ViewOpNew[T1]]
      viewOpOpen[T1](self.asInstanceOf[Rep[ViewOp[T1]]])(newNode.typeA, newNode.evidence$2)
    case Def(node: LeftOuterJoinOpNew[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[LeftOuterJoinOpNew[T1, T2, T3]]
      leftOuterJoinOpOpen[T1, T2, T3](self.asInstanceOf[Rep[LeftOuterJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$3)
    case Def(node: MergeJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[MergeJoinOpNew[T1, T2]]
      mergeJoinOpOpen[T1, T2](self.asInstanceOf[Rep[MergeJoinOp[T1, T2]]])(newNode.typeA, newNode.typeB, newNode.evidence$4)
    case _ => super.operatorOpen[A](self)(typeA)
  }
  override def operatorInit[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = self match {
    case Def(node: ScanOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ScanOpNew[T1]]
      scanOpInit[T1](self.asInstanceOf[Rep[ScanOp[T1]]])(newNode.typeA)
    case Def(node: PrintOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[PrintOpNew[T1]]
      printOpInit[T1](self.asInstanceOf[Rep[PrintOp[T1]]])(newNode.typeA)
    case Def(node: SelectOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SelectOpNew[T1]]
      selectOpInit[T1](self.asInstanceOf[Rep[SelectOp[T1]]])(newNode.typeA)
    case Def(node: AggOpNew[_, _]) =>
      type T1 = Any
      type T2 = Any
      val newNode = node.asInstanceOf[AggOpNew[T1, T2]]
      aggOpInit[T1, T2](self.asInstanceOf[Rep[AggOp[T1, T2]]])(newNode.typeA, newNode.typeB)
    case Def(node: MapOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[MapOpNew[T1]]
      mapOpInit[T1](self.asInstanceOf[Rep[MapOp[T1]]])(newNode.typeA)
    case Def(node: SortOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SortOpNew[T1]]
      sortOpInit[T1](self.asInstanceOf[Rep[SortOp[T1]]])(newNode.typeA)
    case Def(node: HashJoinOpNew1[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew1[T1, T2, T3]]
      hashJoinOpInit[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: HashJoinOpNew2[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew2[T1, T2, T3]]
      hashJoinOpInit[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: WindowOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[WindowOpNew[T1, T2, T3]]
      windowOpInit[T1, T2, T3](self.asInstanceOf[Rep[WindowOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[LeftHashSemiJoinOpNew[T1, T2, T3]]
      leftHashSemiJoinOpInit[T1, T2, T3](self.asInstanceOf[Rep[LeftHashSemiJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: NestedLoopsJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[NestedLoopsJoinOpNew[T1, T2]]
      nestedLoopsJoinOpInit[T1, T2](self.asInstanceOf[Rep[NestedLoopsJoinOp[T1, T2]]])(newNode.typeA, newNode.typeB)
    case Def(node: SubquerySingleResultNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SubquerySingleResultNew[T1]]
      subquerySingleResultInit[T1](self.asInstanceOf[Rep[SubquerySingleResult[T1]]])(newNode.typeA)
    case Def(node: HashJoinAntiNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinAntiNew[T1, T2, T3]]
      hashJoinAntiInit[T1, T2, T3](self.asInstanceOf[Rep[HashJoinAnti[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$1)
    case Def(node: ViewOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ViewOpNew[T1]]
      viewOpInit[T1](self.asInstanceOf[Rep[ViewOp[T1]]])(newNode.typeA, newNode.evidence$2)
    case Def(node: LeftOuterJoinOpNew[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[LeftOuterJoinOpNew[T1, T2, T3]]
      leftOuterJoinOpInit[T1, T2, T3](self.asInstanceOf[Rep[LeftOuterJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$3)
    case Def(node: MergeJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[MergeJoinOpNew[T1, T2]]
      mergeJoinOpInit[T1, T2](self.asInstanceOf[Rep[MergeJoinOp[T1, T2]]])(newNode.typeA, newNode.typeB, newNode.evidence$4)
    case _ => super.operatorInit[A](self)(typeA)
  }
  override def operatorReset[A](self: Rep[Operator[A]])(implicit typeA: TypeRep[A]): Rep[Unit] = self match {
    case Def(node: ScanOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ScanOpNew[T1]]
      scanOpReset[T1](self.asInstanceOf[Rep[ScanOp[T1]]])(newNode.typeA)
    case Def(node: PrintOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[PrintOpNew[T1]]
      printOpReset[T1](self.asInstanceOf[Rep[PrintOp[T1]]])(newNode.typeA)
    case Def(node: SelectOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SelectOpNew[T1]]
      selectOpReset[T1](self.asInstanceOf[Rep[SelectOp[T1]]])(newNode.typeA)
    case Def(node: AggOpNew[_, _]) =>
      type T1 = Any
      type T2 = Any
      val newNode = node.asInstanceOf[AggOpNew[T1, T2]]
      aggOpReset[T1, T2](self.asInstanceOf[Rep[AggOp[T1, T2]]])(newNode.typeA, newNode.typeB)
    case Def(node: MapOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[MapOpNew[T1]]
      mapOpReset[T1](self.asInstanceOf[Rep[MapOp[T1]]])(newNode.typeA)
    case Def(node: SortOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SortOpNew[T1]]
      sortOpReset[T1](self.asInstanceOf[Rep[SortOp[T1]]])(newNode.typeA)
    case Def(node: HashJoinOpNew1[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew1[T1, T2, T3]]
      hashJoinOpReset[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: HashJoinOpNew2[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew2[T1, T2, T3]]
      hashJoinOpReset[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: WindowOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[WindowOpNew[T1, T2, T3]]
      windowOpReset[T1, T2, T3](self.asInstanceOf[Rep[WindowOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[LeftHashSemiJoinOpNew[T1, T2, T3]]
      leftHashSemiJoinOpReset[T1, T2, T3](self.asInstanceOf[Rep[LeftHashSemiJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: NestedLoopsJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[NestedLoopsJoinOpNew[T1, T2]]
      nestedLoopsJoinOpReset[T1, T2](self.asInstanceOf[Rep[NestedLoopsJoinOp[T1, T2]]])(newNode.typeA, newNode.typeB)
    case Def(node: SubquerySingleResultNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SubquerySingleResultNew[T1]]
      subquerySingleResultReset[T1](self.asInstanceOf[Rep[SubquerySingleResult[T1]]])(newNode.typeA)
    case Def(node: HashJoinAntiNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinAntiNew[T1, T2, T3]]
      hashJoinAntiReset[T1, T2, T3](self.asInstanceOf[Rep[HashJoinAnti[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$1)
    case Def(node: ViewOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ViewOpNew[T1]]
      viewOpReset[T1](self.asInstanceOf[Rep[ViewOp[T1]]])(newNode.typeA, newNode.evidence$2)
    case Def(node: LeftOuterJoinOpNew[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[LeftOuterJoinOpNew[T1, T2, T3]]
      leftOuterJoinOpReset[T1, T2, T3](self.asInstanceOf[Rep[LeftOuterJoinOp[T1, T2, T3]]])(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$3)
    case Def(node: MergeJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[MergeJoinOpNew[T1, T2]]
      mergeJoinOpReset[T1, T2](self.asInstanceOf[Rep[MergeJoinOp[T1, T2]]])(newNode.typeA, newNode.typeB, newNode.evidence$4)
    case _ => super.operatorReset[A](self)(typeA)
  }
  override def operatorConsume[A](self: Rep[Operator[A]], tuple: Rep[Record])(implicit typeA: TypeRep[A]): Rep[Unit] = self match {
    case Def(node: ScanOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ScanOpNew[T1]]
      scanOpConsume[T1](self.asInstanceOf[Rep[ScanOp[T1]]], tuple)(newNode.typeA)
    case Def(node: PrintOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[PrintOpNew[T1]]
      printOpConsume[T1](self.asInstanceOf[Rep[PrintOp[T1]]], tuple)(newNode.typeA)
    case Def(node: SelectOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SelectOpNew[T1]]
      selectOpConsume[T1](self.asInstanceOf[Rep[SelectOp[T1]]], tuple)(newNode.typeA)
    case Def(node: AggOpNew[_, _]) =>
      type T1 = Any
      type T2 = Any
      val newNode = node.asInstanceOf[AggOpNew[T1, T2]]
      aggOpConsume[T1, T2](self.asInstanceOf[Rep[AggOp[T1, T2]]], tuple)(newNode.typeA, newNode.typeB)
    case Def(node: MapOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[MapOpNew[T1]]
      mapOpConsume[T1](self.asInstanceOf[Rep[MapOp[T1]]], tuple)(newNode.typeA)
    case Def(node: SortOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SortOpNew[T1]]
      sortOpConsume[T1](self.asInstanceOf[Rep[SortOp[T1]]], tuple)(newNode.typeA)
    case Def(node: HashJoinOpNew1[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew1[T1, T2, T3]]
      hashJoinOpConsume[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]], tuple)(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: HashJoinOpNew2[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinOpNew2[T1, T2, T3]]
      hashJoinOpConsume[T1, T2, T3](self.asInstanceOf[Rep[HashJoinOp[T1, T2, T3]]], tuple)(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: WindowOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[WindowOpNew[T1, T2, T3]]
      windowOpConsume[T1, T2, T3](self.asInstanceOf[Rep[WindowOp[T1, T2, T3]]], tuple)(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: LeftHashSemiJoinOpNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[LeftHashSemiJoinOpNew[T1, T2, T3]]
      leftHashSemiJoinOpConsume[T1, T2, T3](self.asInstanceOf[Rep[LeftHashSemiJoinOp[T1, T2, T3]]], tuple)(newNode.typeA, newNode.typeB, newNode.typeC)
    case Def(node: NestedLoopsJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[NestedLoopsJoinOpNew[T1, T2]]
      nestedLoopsJoinOpConsume[T1, T2](self.asInstanceOf[Rep[NestedLoopsJoinOp[T1, T2]]], tuple)(newNode.typeA, newNode.typeB)
    case Def(node: SubquerySingleResultNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[SubquerySingleResultNew[T1]]
      subquerySingleResultConsume[T1](self.asInstanceOf[Rep[SubquerySingleResult[T1]]], tuple)(newNode.typeA)
    case Def(node: HashJoinAntiNew[_, _, _]) =>
      type T1 = Any
      type T2 = Any
      type T3 = Any
      val newNode = node.asInstanceOf[HashJoinAntiNew[T1, T2, T3]]
      hashJoinAntiConsume[T1, T2, T3](self.asInstanceOf[Rep[HashJoinAnti[T1, T2, T3]]], tuple)(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$1)
    case Def(node: ViewOpNew[_]) =>
      type T1 = Any
      val newNode = node.asInstanceOf[ViewOpNew[T1]]
      viewOpConsume[T1](self.asInstanceOf[Rep[ViewOp[T1]]], tuple)(newNode.typeA, newNode.evidence$2)
    case Def(node: LeftOuterJoinOpNew[_, _, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      type T3 = Any
      val newNode = node.asInstanceOf[LeftOuterJoinOpNew[T1, T2, T3]]
      leftOuterJoinOpConsume[T1, T2, T3](self.asInstanceOf[Rep[LeftOuterJoinOp[T1, T2, T3]]], tuple)(newNode.typeA, newNode.typeB, newNode.typeC, newNode.evidence$3)
    case Def(node: MergeJoinOpNew[_, _]) =>
      type T1 = ch.epfl.data.sc.pardis.shallow.Record
      type T2 = ch.epfl.data.sc.pardis.shallow.Record
      val newNode = node.asInstanceOf[MergeJoinOpNew[T1, T2]]
      mergeJoinOpConsume[T1, T2](self.asInstanceOf[Rep[MergeJoinOp[T1, T2]]], tuple)(newNode.typeA, newNode.typeB, newNode.evidence$4)
    case _ => super.operatorConsume[A](self, tuple)(typeA)
  }
}

trait OperatorsComponent extends OperatorComponent with ScanOpComponent with PrintOpComponent with SelectOpComponent with AggOpComponent with MapOpComponent with SortOpComponent with HashJoinOpComponent with WindowOpComponent with LeftHashSemiJoinOpComponent with NestedLoopsJoinOpComponent with SubquerySingleResultComponent with HashJoinAntiComponent with ViewOpComponent with LeftOuterJoinOpComponent with MergeJoinOpComponent { self: OperatorsComponent => }